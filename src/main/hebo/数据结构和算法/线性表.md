线性表就是数据排成像一条线一样的结构.每个现行表上的数据最多只有前和后两个方向.常见的线性表结构：数组，[链表](https://so.csdn.net/so/search?q=链表&spm=1001.2101.3001.7020)、队列、栈等。



#### 数组

连续的内存空间和相同类型的数据(随机访问的前提)。

优点：两限制使得具有**随机访问**的特性缺点：删除，插入数据效率低。

通过寻址公式：a[i]_address = base_address + i * data_type_size
其中data_type_size表示数组中每个元素的大小,base_address 是首元素地址,i数组下标。



###### 低效的插入和删除

1） 插入：从最好O(1) 最坏O(n) 平均O(n)
2） 插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。



#### 链表

从内存结构来看，链表的内存结构是不连续的内存空间.链表中的每一个内存块被称为节点Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针next。

- 链表的特点

1.插入、删除数据效率高O(1)级别（只需更改指针指向即可），**随机访问**效率低O(n)级别（需要从链头至链尾进行遍历）

2.和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。

- 常用链表

  - 单链表

    1）每个节点只包含一个指针，即后继指针。
    2）单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。
    3）性能特点：插入和删除节点的时间复杂度为O（1）【一般情况下记录两个指针】，查找的时间复杂度为O(n)。

  - 循环链表

    1）除了尾节点的后继指针指向首节点的地址外均与单链表一致。
    2）适用于存储有循环特点的数据，比如约瑟夫问题。

  - 双向链表

     1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。
    2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。
    3）性能特点：
    和单链表相比，存储相同的数据，需要消耗更多的存储空间。
    插入、删除操作比单链表效率更高O(1)级别。以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p->next = q，时间复杂度为O(n)【看单链表的实现方式】，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。
    对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

  - 双向循环链表

##### 数组和链表如何选择

数组缺点
1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。
2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。
3.链表缺点
1）内存空间消耗更大，因为需要额外的空间存储指针信息。
2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。





##### 队列

队列是一种受限的线性表数据结构,只支持两个操作:入栈push()和出栈pop0,队列跟非常相似,支持的操作也 ,很有限,最基本的操作也是两个:入队enqueue(),放一个数据到队列尾部;出队dequeue0),从队列头部取一个元素。

特点:

   1 . 队列跟栈一样,也是一种**抽象**的数据结构。

2. 具有先进先出的特性,支持在队尾插入元素,在队头删除元素。

队列可以用数组来实现,也可以用链表来实现。

###### 基于数组

实现队列需要两个指针:一个是head指针,指向队头;一个是tail指针,指向队尾【队列空的时候指向同一个节点，实际数据的下一位】。

当队列的tail指针移动到数组的最右边后,如果有新的数据入队,我们可以将 head到tail之间的数据,整体搬移到数组中0到tail-head的位置。



###### 基于链表的实现: 

需要两个指针: head指针和tail指针,它们分别指向链表的第一个结点和最后一个结点。

###### 循环队列

原本数组是有头有尾的,是一条直线。现在我们把首尾相,连,板成了一个环。

队列为空的判断条件是head == tail

当队满时, (tail+1)%n=head..你有没有发现,当队列满时,图中的tail指向的位置实际上是没有存储数据的。所以,循环队列会浪费一个数组的存储空间。

解决浪费一个存储空间的思路:定义一个记录队列大小的值size，当这个值与数组大小相等时，表示队列已满，当tail达到最底时，size不等于数组大小时，tail就指向数组第一个位置。当出队时，size—，入队时size++

###### 阻塞队列和并发队列

简单来说,就是在队列为空的时候,从队头取数 , 据会被阻塞。因为此时还没有数据可取,直到队列中有了数据才能返回;如果队列已经满了,那么插入数据的操作就会被阻塞,直到队列中有空闲位置后再插入数据,然后再返回。

阻塞队列就是入队、出队操作可以**阻塞**,并发队列就是队列的操作**多线程安全**。