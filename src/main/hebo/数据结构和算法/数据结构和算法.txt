
数据结构：
[逻辑结构]
1.线性结构（顺序表结构，链表结构【存储结构不同】）  一个数据元素接一个数据元素  数组，链表 ，  队，栈【都可以用数组，链表实现，在此基础上加了限制】，
2.非线性结构    二维数组、图、树、广义表

一部分能用数据结构解决，一部分必须配合算法解决

稀疏数组：记录数组的行列以及数值。第一行存的是原始数组的行列数及有效值。



---2：环形队列

数组里可以用变量、表达式做索引


---单链表
头结点（可有，只存放link） 在添加和查询时从头结点【引用不能动】开始循环链表，通过临时变量tmp=tmp.next.
插入时通过插入的前一个节点做辅助节点。newNode.next=tmp2.next tmp2.next=newNode


链表类 节点类
遍历：得到size
传入：头插和尾插【遍历到最后添加】
删除【根据信息在遍历中查找到对应节点的前一个节点（即从头节点开始）  通过tmp.next.no=no】、查询、更新、得到头节点：

例子：将一个链表反序   
1.传入头结点，判断大小
2.当前节点，当前节点的下一个节点【在反转头节点头插法插入时需要记录，不然原链断裂】  反转头节点

链表反序打印
1.通过栈的方式进行

---双向链表【指向前后节点两个指针】：可以直接删除元素（）


----单项循环链表
约瑟夫问题
头节点
临时节点
新增节点

1.新建循环链表  传入节点个数，自动进行构建   多了一步设置指向头节点的步骤
2.遍历结束 临时节点.next=first
3.出圈： helper（通过循环确定其为first之前的节点） 和 first指针    移动m-1次   判断是否结束 helper==first  出圈操作

--栈
应用： 子程序调用  递归  表达式转化  二叉树遍历  图的深度搜索

数组模拟栈  栈类封装数组，通过成员方法逻辑上构建栈  top=-1 入栈 top++  a[top]=value   出栈： value=a[top] top--   遍历从栈顶开始  检查栈空和栈满  peek栈顶  

用链表模拟栈（用头插法  在任意位置链表比数组更易增删）


例子：
计算器  输入一个表达式
有一个数栈  符号栈

符号栈里面的后面的优先级必须大于前面的 否则弹出两个数，一个符号，先计算后的数字入数栈  空栈直接入

是否操作符（多位数）   操作符优先级

前缀表达式  符号完全在前  从右到左  数字入栈  遇到符号弹出计算再入栈
中缀表达式
后缀表达式   从左到右 数字入栈  遇到符号计算再入栈



后缀表达式计算器实现：


中缀表达式转后缀表达式： 循环中缀list 通过后缀List存表达式（数字直接存，符号需进行判断）  在转化过程中通过栈记录中间变量【item遇到左括号入栈，遇到右括号出栈此时栈顶并接入List，弹出左括号    遇到运算符，优先级低于等于栈顶则弹出并接入List，继续与栈顶比较。否则压入栈】          

2+4*5

2,4,5,*,+

--leetCode
凡是有重需要去掉考虑HashSet

对传入的参数做校验[考虑边界情况]
通过map统计集合或者数组中元素出现的次数



ArrayList从尾部开始添加	

char和int可以相互转换  减去ascll差值 或者 对应字符

一个字符串可以拆分成集合里。【相比通过循环和subSting去抽取】

递归三步曲 1.递归结算条件  2.返回值   3.一次递归应该需要做什么
https://leetcode-cn.com/problems/pascals-triangle/solution/javadi-gui-dong-tai-gui-hua-by-jeromememory/
迷宫问题  二维数组表示地图  不同的数字表示不同状态 （0,1,2,3） 行走策略（上下左右）

递归按照策略在中间不断的回溯【指当前所有方向都是false，此时退回上一层尝试此层的其他方向】。

最短路径：循环不同策略（没学算法时）

排列公式（含顺序） Amn=n*....(n-m+1)
组合公式    Cnm=Amn/n!

八皇后问题  92种

用一位数组表示地图

传入第N个皇后，循环判断与现有皇后是否同列，是否同一斜线。【本身就在不同行】

通过循环【测试当前皇后哪一列满足】和递归【满足后开始n+1个皇后】  n==8【从零开始，到此表示满足了条件的摆放位置】 递归结束
回溯：无论满不满足条件，都会逐层反向回溯，

时间频度=时间复杂度：T(n)=O（f（N））  
F（N) 同数量级函数  常数和低次项省虐


平均时间复杂度
最坏时间复杂度  一般考虑这个

空间复杂度（一般不考虑，缓存产品就是用空间换时间，用户不care）


冒泡排序
优化点：1.如果一次都没交换，就直接结束剩下轮次。
选择排序（记录最小值和最小值索引，最后进行交换）
n-1轮，每轮有一个循环
查找最小值，与A[0]进行交换

最值   有序

从前往后  从后往前

插入排序  记录插入的值，和插入位置的前一个位置 
有序部分  无序部分   从无序选择元素插入到有序部分
希尔排序  长度除二得到增量分组  分组内插入排序  让较小的数挪到前面
轮次（多少次分组）  
分组大小
遍历组内元素

编码：（三个循环） 循环长度不断除2 直到0  以每次的分组数为起点，以分组数为步长（不断加入数，与每一个比较，交换  所以和插入排序一组）
时间复杂度  n*n*logn   效率慢，因为全部比较了

移位法：结合插入排序【替换里面的二次循环】

快速排序【冒泡方式改进】
递归： 一次排序分为两个部分   
指定一个基准位置   左右指针while（r<l）  在左边找到一个大于基值得【循环】，右边找到一个小于基值的【循环】。在交换位置
https://blog.csdn.net/shujuelin/article/details/82423852

归并排序【分治算法】
先分后排序
最好的请情况下：
利用递归分之，一次递归里面调用两次自身（左右不分）
比较 填充 拷贝

基数排序
找到最大值，得到位数【加上空串得到长度】
二维数组（桶）  一维数组（记录每个桶中放的数据个数）
统一数的位数  从个位开始放入桶中

模10得到数的个位数


顺序查找
二分查找（必须是有序的）
left》right 退出未找到
finalvlue=midvalue 找到退出
向左向右递归

插值查找【mid值得改进】 数值分析-线性插值【斜率】
特殊情况下数字分布不均情况比二分差

斐波那契查找【mid值改进】
斐波那契数列找一个等于略大于查找表中元素个数的数F[n]
https://blog.csdn.net/jinyan1111/article/details/79916455
1.创建斐波那契数列
2.找到适合数组长度的斐波那契数值对应的下标K
3.创建临时数组f(k)-1个长度，复制原数组。并填充
4.mid = low + f[k - 1] - 1;    

总结：一般情况下排序的时间复杂度是n*n 各个算法的改进就是减少比较次数

哈希表【数据结构】  减少了查询次数
数组+链表
数组+二叉树

实现：节点  链表【第一个节点是头节点，通过辅助节点到最后一个节点添加】  数组【HashTable】不要忘了初始化


树结构
相比数组存储【易于通过下标查找，有序数组可二分】，链式存储增删改查效率更高

有序数列时二叉树就是链表【可以看出查询确实变快了】

二叉树  满二叉树  完全二叉树

前序【当前节点，遍历右，遍历左】后序中序  看父节点输出的位置
遍历
12354
21534
25431
查找 三种方式  各比较了多少次

删除节点  判断当前节点的子节点是否需要删除  考虑是否是空树
1.叶子节点
2.

顺序存储二叉树
二叉树用数组存储【公式逻辑指针，之前是用链表存的】
第N个元素，左子节点2*n+1 右子节点2*n+2

线索二叉树（将树的空余n+1个指针指向前驱节点、后驱节点）【以中序遍历为例】 有效利用指针
需要当前节点的前驱节点指针
可以线性遍历  当前节点子节点是线索化类型就循环打印 不然就node=node.child

堆排序
1.构建大顶堆（数组方式，升序）  最后一个非叶子节点 比较左右子节点
2.得到最大值，剩下元素递归1

最优二叉树 哈夫曼树 带权路径长度最小wpl  权乘路径
权值越大离根节点越近
构建：不断选取权最小的两个二叉树组装【权所在为叶子节点】  集合排序
处理过的节点删除  添加新增节点  直到集合大小为1 
对集合进行排序
节点实现比较器接口（一般从小到大） 然后Colletions.sort(Nodes);
哈夫曼树可能因为有大量重复权值导致结构不一样，但是wpl一样

变长编码 过度  直接编码会有二义性

哈夫曼编码【算法】  前缀编码  压缩
各个字符根据出现的字符次数作为权值【可以重复】构建哈夫曼树  【出现频次最高的编码最少】
规定向左路径为0，向右路径为1  从根到叶路径唯一性【不会出现二义性】

二叉排序树 BST【解决链表无论是否有序都是逐一查找的问题，查找效率提升到有序数组】
区别：构建树的时候会考虑大小，小于父节点在左节点

删除叶子节点 【需要父节点和目标节点】
删除子树节点，但只有一个子节点
删除子树节点 【从右子树获得最小值  删除节点并返回具体值重置targetnode】

二叉平衡树【前提是二叉排序树】 AVl 保证查询效率  高度差不超1
在添加节点后再判断高度，进行旋转生成二叉平衡树

双旋转【一次旋转不能平衡的情况】 根节点的左子树的  右子树比右子树高 则先对左子树进行左旋转，在进行整体右旋转



  图
  有向图
  带权图

  表示方式  二维数组【邻接矩阵】 行列代表元素  值代表连接  空间浪费
             数组+链表 邻接表   下标代表元素  链表具体值代表能连接的元素

             创建： 集合【点】  二维数组【边】  边数量
             遍历：DFS  第一个邻接节点 其他邻接节点    递归访问
                  BFS  借用队列



十大算法
二分查找的非递归方式
分治算法【比例缩小】   在限定规模下能容易的得到解法
1.分解 2.解决  3.合并
例：汉罗塔 【分治思想--递归解法】 一个盘  两个盘【其余盘类推 看成第N个盘和其余盘】
N个盘和2两盘的过程一致
一次递归如下【】
1.将n-1个盘从A移到B盘，
  将n从A移到C     

2.将n-1个从B移到C

直到n=1 递归结束

动态规划算法【子问题不独立】

1.化表法

当前物品能否放进去，放进去后剩余空间能放的最大值【从之前的列取】  与上一行的同列数据取最大值
不能放进去直接去上一行的数据

KMP算法（在一个字符串里查找子串）
部分匹配表 子串前缀和后缀公有元素的长度   子串长度逐渐增大
移动位数：已匹配的字符数-对应的部分匹配表

贪心算法
在每一步都采取最优的解法 
但是结果最后可能不是最优

例：广播选择
每一次计算广播覆盖的实际地区数量  选择覆盖量最大的广播，并去除总量中的选项

工作是否有前景，看需不需要动脑子
  MST最小生成树【N个顶点需要n-1条边】
1.prim算法

从一个点开始，过程计算最短边的相邻点加入【前提是未访问过】 直到最后
2.克鲁斯卡尔算法
按照权值从小到大连接顶点 不构成回路
1.对权值进行排序
2.不形成回路




=====leetcode

                  1.泛型必须用引用类型。泛型要求包容的是对象类型，而基本数据类型在Java中不属于对象
                  2.Integer中方法compare和compareTo的区别//compareTo
    public int compareTo(Integer anotherInteger) {
        return compare(this.value, anotherInteger.value);
    }
    
    //compare
    public static int compare(int x, int y) {
        return (x < y) ? -1 : ((x == y) ? 0 : 1);
    }
             3.因为-128到127这些数字是使用频率比较高的，就产生了一个整型常量池，这些数字会存放在这里，有相同的数字则不会再次创建
             4.在变量声明那规定泛型类型
             5.String类型的substring方法左闭右开
             6.注意用int或者long
             通过桶排序来放次数
             位运算优先级较低
    
             窗口理论：滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)O(n)
    
             双指针理论【夹逼】
             快慢指针：右指针可以回溯
             桶思想： 数组的值当新数组的下标
             弗洛伊德循环查找【判断是否有循环】 快慢指针
             　String：适用于少量的字符串操作的情况【不可变对象。不断创建和删除对象】
           摩尔投票法：通过消掉n不同的元素，（最后得到出现次数最多的数，需要检验是否剩下的候选值是否满足条件）
             比较大小可以转为计算
             无符号右移是指无论正负左边都填充0
               n&1 看n二进制最后一位返回0或者1
              n与n-1做逻辑与运算（【n-1 本质是使其每次的最右边的1变为0，其右边全变为1】，做完运算后的结果赋值给n
              把一重循环转为集合
              一个Integer就是一个32位的Boolean数组（位运算）

　　StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况

　　StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况
递归就是压栈

7.单调栈 ：通过一个栈记录值，比栈顶小就入栈，比栈顶小则栈顶出栈记录在hashMap中然后再入栈

