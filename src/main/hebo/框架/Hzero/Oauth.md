oauth保证了访问资源的安全性以及灵活性。他允许用户不把某系统的账号密码提供给第三方，第三方就能访问到此用户该系统上的信息，使第三方应用可以更安全的访问资源。

Security使用了责任链的设计模式，他提供了一个非常长的过滤器链完成完成认证、授权、鉴权的相关操作。

Security本身是一套完整的认证和授权解决方案，他是一条很长的过滤器链，使用oauth和JWT需要在过滤器链中定义oauth和JW他的具体实现。

系统需要给第三方系统做授权，就需要实现oauth。

用户必须在 A 的网站里输入他在 B 的账号和密码。如果你是一个隐私意识很强的人，你很可能会问：“凭什么我要把 B 的账号密码告诉 A ？”这里，从用户的角度就已经感受到一种不安全感，凭什么让我信任你 A，你保证不拿我的 B 账号密码去干坏事？而更深一层次，站在 B 的角度来考虑的话，也是一样的问题：我凭什么绝对信任 A？如果 A 在接收到用户的输入之后，马上就把请求发到我们这里来，那是 ok 的。但是万一 A 在这个过程偷偷把账号密码存起来了呢？那随着时间的推移，A 就慢慢地搜集到一大批 B 的账号密码！这对 B 来讲，是不能接受的！

###### 授权码模式（authorization code）

 

授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点是通过客户端的后台服务器，与“服务提供商”的认证服务进行互动（如微信开放平台），我们前面以微信账号登录豆瓣网的流程就是授权码模式的实现。这种模式下授权代码并不是客户端直接从资源所有者获取，而是通过授权服务器（authorization server）作为中介来获取，授权认证的过程也是资源所有者直接通过授权服务器进行身份认证，避免了资源所有者身份凭证与客户端共享的可能，因此是十分安全的。

例如，微信用户授权登录豆瓣网的过程中，微信授权认证是直接在微信的网站上进行的，即便是输入用户名密码也只有微信授权认证服务器可以获取，因此豆瓣网是感知不到的，从而避免了微信用户账号信息在第三方网站泄露的风险。

只在后台应用进行，access_token不会出现在浏览器。

![img](https://img2020.cnblogs.com/blog/419544/202106/419544-20210609172848603-384012851.png)

1，用户访问 A 网站

　　2，A 打开 B 的授权页面

　　3，用户看到授权界面，输入账号密码进行授权

　　4，B 验证用户是合法的之后，生成一个 authorization code，然后通过 302 跳转的方式，把这个 code 发送给 A

　　5，A 用这个 code 调用 B 的 api，获得 access token

　　6，A 用 access token 访问资源

 

　　问题来了，authorization code 是什么？

　　- code 一个一次性的临时凭证，可以用它来兑换 access token

　　- code 是由鉴权服务器生成的一个随机且唯一的字符串

　　- 鉴权服务器会记录下 code 的生成时间、将要兑换给谁（例子里是 A）、授权的用户是谁

　　- 在第 5 步，鉴权服务器会验证 A 的身份，并且检查 code 的有效期。通过的话就会生成 access token

　　- code 是一次性的，在第 5 步成功换取 access token 之后就会作废

　　- code 的有效期非常短，可能不会超过 1 分钟。A 在第 4 步获取到 code 之后，要立刻走第 5 步

 

　　为什么不在第 4 步直接把 access token 发送给 A，而要通过看似多余的 code 再转换一下，搞这么复杂呢？这个问题的答案非常重要，是整个授权流程的关键所在。

　　如果在第 4 步直接把 access token 发送给 A，会有什么问题呢？

　　问题就是，第 4 步是一个 302 跳转，如果在第 4 步传递 access token，会导致 access token 暴露在 url 中，这是非常不安全的方式，因为 url 很容易捕捉到。

 

　　所以我们不能在第 4 步直接传递 access token。那换成一个 code，再用 code 去换，就更安全了吗？你可以能会问，code 同样会泄漏，那攻击者拿到 code，也可以用 code 去换 access token，有什么区别呢？

　　区别在于，攻击者拿到 code 是不能拿去换 access token 的，两个原因：

　　1，上面说了，换取 access token 的时候，鉴权服务器会验证 A 的身份。具体怎么验证，在后面说明。

　　2，code 的有效期极短，留给攻击者的时间极短

　　另外，即便攻击者成功突破了上面两个限制，拿到了 access token，鉴权服务器也能很快发现。这是因为，攻击者必须抢在 A 之前去兑换 access token。那么，等到 A 走第 5 步的时候，鉴权服务器就会发现，这个 code 已经被用过了。此时这就是一个攻击已经发生的信号：有两个不同的服务器，尝试用同一个 code 来兑换 access token，正常情况下是不应该发生的。此时鉴权服务器可以立刻采取措施。例如，可以把刚才兑换出去的 access token 作废。所以，搞出来一个 code，确实会安全很多。

所有的 A，应该说都是 B 的合作方。那么在开始合作之前，一定需要做一些前期的准备。具体来说，B 通常会提供一个申请网站，A 通过这个网站填写一些信息，提交合作申请。B 的工作人员会审核，通过之后，系统会给 A 自动分配一个 client_id 和一个 client_secret。client_id 就是一个唯一 id，client_secret 是一个密钥。A 需要把 client_secret 妥善保管在服务器上，不能泄露。在用 code 兑换 access token 的时候，需要用这个 client_secret 对请求生成 MAC（消息验证码）。鉴权服务器就是依靠这个 MAC 来验证 A 的身份的。

###### 简化模式

简化模式是对授权码模式的简化，用于在浏览器中使用脚本语言如JS实现的客户端中，它的特点是不通过客户端应用程序的服务器，而是直接在浏览器中向认证服务器申请令牌，跳过了“授权码临时凭证”这个步骤。其所有的步骤都在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。【区分和密码模式、提供了登陆页面（即是认证中心自己的服务）】

但是由于这种方式访问令牌access_token会在URL片段中进行传输，因此可能会导致访问令牌被其他未经授权的第三方截取，所以安全性上并不是那么的强壮。

###### 密码模式

密码模式中需要用户提供自己的账号密码给客户端，客户端使用用户的账号密码和client_id client_secret去授权服务器请求token。

在密码模式中，用户需要向客户端提供自己的用户名和密码，客户端使用这些信息向“服务提供商”索要授权。这相当于在豆瓣网中使用微信登录，我们需要在豆瓣网输入微信的用户名和密码，然后由豆瓣网使用我们的微信用户名和密码去向微信服务器获取授权信息。

###### 客户端模式

客户端以自己的名义，而不是以用户的名义 去授权服务器申请token



参考：https://www.cnblogs.com/wudimanong/p/10821215.html

