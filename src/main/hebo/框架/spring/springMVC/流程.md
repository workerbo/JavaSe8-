##### 总结

ServletContext官方叫servlet上下文。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享。

Tomcat启动时，监听器ContextLoaderListener创建一个XMLWebApplicationContext上下文容器，并加载context-param中的配置文件，**完成ROOT容器的刷新后将上下文设置到ServletContext**，绑定ServletContext到Spring根上下文。当DispatcherServlet创建时，先进行初始化操作，从ServletContext中查询出监听器中创建的上下文对象，作为父类上下文来创建servlet的上下文容器，并加载Servlet配置中的init-param的配置文件

ServletContextListener监听ServletContext的生命周期。每个web application对应一个ServletContext，用于servlet与servlet容器沟通的中介。它定义两个方法，context初始化和context销毁。SpringMVC的ContextLoaderListener实现了此接口，在web application启动时创建一个Spring的ROOT上下文。

```
servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

```

servlet子上下文的创建也有几个关键点

1. 从ServletContext中获取第一步中创建的SpringMVC根上下文，为下面做准备
2. 根据init-param中的contextAttribute属性值从ServletContext查找是否存在上下文对象
3. 以XmlWebApplicationContext作为Class类型创建上下文对象，设置父类上下文，并完成刷新
4. 执行子类扩展方法onRefresh，在DispatcherServlet内初始化所有web相关组件
5. 将servlet子上下文对象发布到ServletContext

SpringMVC在DispatcherServlet的初始化过程中，同样会初始化一个WebApplicationContext的实现类，作为自己独有的上下文，这个独有的上下文，会将上面的根上下文作为自己的父上下文，来存放SpringMVC的配置元素，然后同样作为ServletContext的一个属性【双向绑定】，被设置到ServletContext中，只不过它的key就稍微有点不同，key和具体的DispatcherServlet注册在web.xml文件中的名字有关，从这一点也决定了，**我们可以在web.xml文件中注册多个DispatcherServlet，因为Servlet容器中注册的Servlet名字肯定不一样，设置到Servlet环境中的key也肯定不同。**



在servlet子上下文完成创建，调用了模板扩展方法OnRefresh，它在FrameworkServlet中仅仅只是个空方法，但在其子类DispatcherServlet中则至关重要，它是一切组件的起源。

**当RequestMappingHandlerMapping对象初始化时，会调用InitializingBean接口的afterPropertiesSet方法。在此方法中完成了Controller方法同请求url的映射表。**

在servlet子上下文完成创建，调用了模板扩展方法OnRefresh，它在FrameworkServlet中仅仅只是个空方法，但在其子类DispatcherServlet中则至关重要，它是一切组件的起源。

这些转换器也是需要初始化到运行环境中的， 谁的运行环境， HandlerAdapter的。

同样SpringMVC提供了一个默认的强大实现，RequestMappingHandlerAdapter，同样在``中定义。它也实现了InitializingBean接口。

同***\*RequestMappingHandlerMapping\**，RequestMappingHandlerAdapter**会被注册到SpringMvc的容器中，此对象中有所有的处理器，也就是List或者Map,最后在DispatcherServlet的init方法中的**initHandlerAdapters方法中会找到这个\**RequestMappingHandlerAdapter并放到DispatcherServlet的\**handlerAdapters中**

##### DispatcherServlet处理流程

SpringMVC框架和其他请求驱动的表示层框架一样，也是围绕一个将请求分发到相应控制器的核心Servlet来设计的。DispatcherServlet和其他框架中的Servlet不一样的地方在于，它和Spring容器无缝整合在了一起，因此你可以在SpringMVC中使用Spring容器所有的特性。

SpringMVC完成初始化流程之后，就进入Servlet标准生命周期的第二个阶段，即“service”阶段。在“service”阶段中，每一次Http请求到来，容器都会启动一个请求线程，通过service()方法，委派到doGet()或者doPost()这些方法，完成Http请求的处理。

将Spring上下文关联到Servlet容器中，是SpringMVC框架的第一个亮点，那么在请求转发流程中，SpringMVC对各种处理环节编程元素的抽象，就是另外一个独具匠心的亮点。【Servlet对象放在了spring容器中】

**整个SpringMVC框架，都是依托着Servlet容器元素来设计的**

正发生请求转发的方法doDispatch()中，它的参数是HttpServletRequest和HttpServletResponse对象。这给我们传递的意思也很明确，**从request中能获取到一切请求的数据，从response中，我们又可以往服务器端输出任何响应，Http请求的处理，就应该围绕这两个对象来设计**