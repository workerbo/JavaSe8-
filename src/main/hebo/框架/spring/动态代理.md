





#### 1.JDK动态代理。

【原对象必须有接口，横切逻辑在接口InvocationHandler中，运行期间生成代理对象】【原对象的执行用到了反射】

JDK动态代理是基于Java的反射机制实现的，主要涉及到java.lang.reflect包中的Proxy和InvocationHandler。
InvocationHandler是一个接口，通过实现这个接口定义一个横切的逻辑！然后通过反射机制调用目标类的方法，这样就能动态的把非业务逻辑和业务逻辑动态的拼接在一起！
Proxy类负责创建代理对象时，指定了handler（处理器），那么不管用户调用代理对象的什么方法，该方法都是调用处理器的invoke方法。里边的invoke方法确保调用原对象的interface定义的方法都从这里进入。
1、代理对象存在的价值主要用于拦截对真实业务对象的访问。
2、代理对象应该具有和目标对象(真实业务对象)相同的方法。【里面去调用invoke方法】

###### [机制讲解](https://blog.csdn.net/Dream_Weave/article/details/84183247)

```
public class DynamicProxy implements InvocationHandler
{
    // 这个就是我们要代理的真实对象
    private Object subject;
    
    // 构造方法，给我们要代理的真实对象赋初值
    public DynamicProxy(Object subject)
    {
        this.subject = subject;
    }
    
    @Override
    public Object invoke(Object object, Method method, Object[] args)
            throws Throwable
    {
        // 在代理真实对象前我们可以添加一些自己的操作
        System.out.println("before rent house");
        
        System.out.println("Method:" + method);
        
        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
        method.invoke(subject, args);
        
        // 在代理真实对象后我们也可以添加一些自己的操作
        System.out.println("after rent house");
        
        return null;
    }
}
Object invoke(Object proxy, Method method, Object[] args) throws Throwable
 
proxy:　 - 代理对象
method:　- 指代的是我们所要调用真实对象的某个方法的Method对象
args:　　- 指代的是调用真实对象某个方法时接受的参数

public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException
 
loader:　　    一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载
 
interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
 
h:　　         一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上
```



```
public class Client
{
    public static void main(String[] args)
    {
        // 我们要代理的真实对象
        Subject realSubject = new RealSubject();
 
        // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的
        DynamicProxy实现了InvocationHandler，重写了invoke方法
        InvocationHandler handler = new DynamicProxy(realSubject);
 
        /*
         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数
         * 第一个参数handler.getClass().getClassLoader()，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象
         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了
         * 第三个参数handler，我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上
         
         我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口
         */
        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject
                .getClass().getInterfaces(), handler);
        
        System.out.println(subject.getClass().getName());
        subject.rent();
        subject.hello("world");
    }
}
$Proxy0  【生成的代理类类名】
 
before rent house
Method:public abstract void com.xiaoluo.dynamicproxy.Subject.rent()
I want to rent my house
after rent house
 
before rent house
Method:public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String)
hello: world
after rent house
```

###### 动态代理(Proxy)[源码分析](https://www.cnblogs.com/zhangchengzi/p/9713807.html)

Proxy.newProxyInstance

// 查找或者是生成一个特定的代理类对象
        Class<?> cl = getProxyClass0(loader, intfs);

// 通过反射，将h作为参数，实例化代理类，返回代理类实例。          

​         return cons.newInstance(new Object[]{h});

https://blog.csdn.net/lovejj1994/article/details/78080124



### 2.动态字节码技术【CGLIB（底层是ASM）】[参考](https://blog.csdn.net/yhl_jxy/article/details/80633194)

```
package com.jpeony.spring.proxy.cglib;
 
import net.sf.cglib.core.DebuggingClassWriter;
import net.sf.cglib.proxy.Enhancer;
 
public class Client {
    public static void main(String[] args) {
        // 代理类class文件存入本地磁盘方便我们反编译查看源码
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "D:\\code");
        // 通过CGLIB动态代理获取代理对象的过程
        Enhancer enhancer = new Enhancer();
        // 设置enhancer对象的父类
        enhancer.setSuperclass(HelloService.class);
        // 设置enhancer的回调对象
        enhancer.setCallback(new MyMethodInterceptor());
        // 创建代理对象
        HelloService proxy= (HelloService)enhancer.create();
        // 通过代理对象调用目标方法
        proxy.sayHello();
    }
}

package com.jpeony.spring.proxy.cglib;
 
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
 
import java.lang.reflect.Method;
 
/**
 * 自定义MethodInterceptor
 */
public class MyMethodInterceptor implements MethodInterceptor{
 
    /**
     * sub：cglib生成的代理对象
     * method：被代理对象方法
     * objects：方法入参
     * methodProxy: 代理方法
     */
    @Override
    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("======插入前置通知======");
        Object object = methodProxy.invokeSuper(sub, objects);
        System.out.println("======插入后者通知======");
        return object;
    }
}
```

cglib是通过继承目标类生成代理对象【会重写方法，和增加一个代理方法】，代理对象调用方法【方法中会调用拦截器（横切逻辑，和调用代理方法）】（fastclass机制）

#### fastclass机制

简单理解一下FastClass：为一个对象A创建它的FastClass对象，这个FastClass对象相当于A的方法索引，根据A的方法名生成并关联一个index、每个index对应A的一个方法。后续只要根据这个index以及A的实例，就可以调用fastClass的`invoke(instanceOfA, index, args)`方法来快速的调用A的方法了【方法里根据索引switch到不同的实例对象去调用方法】。实现了Java反射的“运行时动态调用指定类的方法”的功能，但是使用了不同的机制。

```
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * 为每个委托类动态生成FastClass类
 * */
@Slf4j
public class DummyServiceFactClass {

    //sign方法签名
    public int getIndex(String sign){
        switch (sign){
            case "service1":
                return 1;
            case "service2":
                return 2;
        }
        return 0;
    }

    //index方法索引， obj调用对象， args方法参数
    public Object invoke(int index, Object obj, Object[] args){
        DummyService dummyService = (DummyService) obj;
        switch (index){
            case 1:
                return dummyService.service1((String)args[0]);
            case 2:
                dummyService.service2((String)args[0]);
                return null;
        }
        return null;
    }

    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        DummyService dummyService = new DummyService();
        //使用FastClass
        DummyServiceFactClass dummyServiceFactClass = new DummyServiceFactClass();
        int index1 = dummyServiceFactClass.getIndex("service1");
        int index2 = dummyServiceFactClass.getIndex("service2");

        Object ret1 = dummyServiceFactClass.invoke(1, dummyService, new Object[]{"123"});
        Object ret2 = dummyServiceFactClass.invoke(2, dummyService, new Object[]{"456"});

        log.info("ret1 = {}, ret2 = {}", ret1, ret2);

        //使用反射
        Class clazz = dummyService.getClass();
        Method method1 = clazz.getDeclaredMethod("service1", String.class);
        Method method2 = clazz.getDeclaredMethod("service2", String.class);

        ret1 = method1.invoke(dummyService,"123f");
        ret2 = method2.invoke(dummyService, "345f");

        log.info("ret1 = {}, ret2 = {}", ret1, ret2);
    }
}

```





最后我们总结一下JDK动态代理和Gglib动态代理的区别：
1.JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
2.JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。
3.JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。



