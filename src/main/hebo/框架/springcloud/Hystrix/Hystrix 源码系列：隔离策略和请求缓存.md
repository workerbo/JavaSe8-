###  Thread Pool

将各依赖服务的访问交由**独立的线程池**来处理，会为每个依赖服务创建一个线程池。虽然可以起到很好的隔离作用，但也增加了计算开销，每个命令的执行都涉及到queueing、scheduling、**context switching**。

### Semaphore

通过为各依赖服务设置信号量(或计数器)来限制并发调用，相当于对各依赖服务做限流。信号量模式下任务由当前线程直接处理，**不涉及到线程切换**，自然也就没有超时控制。





## 请求缓存

微服务中，服务之间的依赖非常多，为了提升性能，如果每个方法都自行处理缓存的话，应用中可以想象有多少累赘的缓存代码。在请求生命周期内，无论是当前线程，还是其他线程，只要请求相同的数据，就自动做缓存，不侵入业务代码。

