



### ES6学习笔记

#### symbol

防止属性名的冲突。这就是 ES6 引入`Symbol`

由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

`Symbol`函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述

由于每一个 Symbol 值都是不相等的。同时不能隐式转换为其他类型。

因为生成的 Symbol 是一个原始类型的值，不是对象。

##### 对象

属性的简洁表示法 

属性名表达式与简洁表示法，不能同时使用

`Object.getOwnPropertyDescriptor`方法可以获取该属性的描述对象。

`for...in`循环：只遍历对象自身的和继承的可枚举的属性

`this`关键字总是指向函数所在的当前对象，`super`，指向当前对象的原型对象。

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构

可以按照模式不完全解构

数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

解构赋值允许指定默认值。【一个数组成员严格等于`undefined`，默认值才会生效。】

对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

链判断运算符 ？  Null 判断运算符？？

七种语言类型【弱类型语言：变量类型完全由当前的值决定，这就叫弱类型。强类型更有利，可以降低系统的复杂度】和内置对象。对象具有动态性。JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。

弱/强类型值的是，是否允许不兼容的类型进行运算。比如在Javascript中，“4”-3的结果是数字1，这里字符串和数字做运算了。在强类型的语言中时不可以做这样的计算的。

动态/静态类型，值得是声明一个变量之后，它是否可以存储（指向）不同类型的变量。

考虑到 JavaScript 中将函数设计成一种特殊对象，所以 JavaScript 中的行为和状态都能用属性来抽象。

JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。

JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。【属性的索引结构】

在 ES6 之后 => 语法创建的函数仅仅是函数，它们无法被当作构造器使用。

##### 面向对象编程

 JavaScript 中两种面向对象编程的范式：基于类【一种模拟】和基于原型

原型系统可以说相当简单，我可以用两条概括：

- 如果所有对象都有私有字段 [[prototype]]【实现就是将`[[Prototype]]`命名为`__proto__`】，就是对象的原型；
- 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。

ES6基于原型

- Object.create 根据指定的原型创建新对象，原型可以是 null；
- Object.getPrototypeOf 获得一个对象的原型；
- Object.setPrototypeOf 设置一个对象的原型。



函数被调用，以构造器【模拟类】的 prototype 属性为原型，创建新对象,将 this 和调用参数传给构造器，执行；如果构造器返回的是对象，则返回，否则返回第一步创建的对象。新对象成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用。

ES6推出了class关键字。使得类定义与函数定义分离。【类其实就是构造函数的另外一种写法】。类的写法实际上也是由原型运行时来承载的。

非方法的属性称为实例属性（即定义在this对象上），其余的可以称为原型属性（即定义在class的原型上)。[不同版本规范不同]

hasOwnProperty()函数用于判断属性是否是实例属性。in操作符 能访问的属性

##### 原型链

①`__proto__`和`constructor`属性是**对象**所独有的；② `prototype`属性是**函数**所独有的。但是由于JS中函数也是一种对象，所以函数也拥有`__proto__`和`constructor`属性。__proto__属性的作用就是形成原型链。prototype属性的作用就是函数所实例化的对象找到公用的属性和方法，即f1.__proto__ === Foo.prototype。 constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 另外 __proto__ 属性是浏览器对es5的实现，而不是es标准。

**任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。**

构造函数上的方法和属性是静态的，不能被继承。【以Object函数为例】

把对象分成几类。

- 宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。
- 内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。
  - 固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。
  - 原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。
  - 普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。

用对象来模拟函数与构造器：函数对象与构造器对象。函数对象的定义是：具有 [[call]] 私有字段的对象，构造器对象的定义是：具有私有字段 [[construct]] 的对象。

##### 函数

返回 Promise 的函数都可以认为是异步函数。

`Promise`对象代表一个异步操作

`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供。改变容器的状态并传值到容器外。

`then`方法返回的是一个新的`Promise`实例

立即执行函数表达式避免了变量冲突【全局变量变成局部变量】，块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

闭包就是将函数内部和函数外部连接起来的一座桥梁。【所以获取函数内部的局部变量：在函数的内部，再定义一个函数并返回】。【绑定了作用域链函数】。

##### 链式作用域与this环境对象

 JS在函数内可以读取全局变量，函数外不可以读取用var声明的变量【局部变量】。函数内变量不用var声明就是全局变量。

"链式作用域"结构（chain scope）【顶层作用域和函数作用域、块级作用域声明】，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的。【与变量作用域相关】



```
function f1(){
　　　　var n=999;  //局部变量
　　　　nAdd=function(){n+=1}//没有使用var关键字，因此nAdd是一个全局变量,这个匿名函数本身也是一个闭包,在函数外部对函数内部的局部变量进行操作。
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();//f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存
　　result(); // 999
　　nAdd();
　　result(); // 1000
　
```

```
var a=3;
var obj={a:55,
      inner:{a:99,db:function(){ 
                   console.log(a); //3   作用域链[自身局部变量上没找到，则到上层全局变量去找]
                   console.log(this.a);}//99  this环境对象。如果调用对象inner没有a属性则显示undefined
             }};

obj.inner.db();

 
```

this是JavaScript的一个关键字，他是指函数执行过程中，自动生成的一个内部对象，是指当前的对象，只在当前函数内部使用。`this`就是函数运行时所在的环境对象。

1.全局环境

2.函数中 2.1直接调用 2.2 对象调用  2.3构造函数 2.4 事件函数 2.5内联事件函数。

3.bind apply call 方法【指定值】

4.箭头函数。【`this`从外部方法定义中保留值】

this一般从词法上下文【箭头函数的this是在定义函数时绑定的，不是在执行过程中绑定的】、调用函数时的对象【严格模式下不会默认为window】。自执行函数，this的指针是window，自执行函数被window调用。

箭头函数解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性）

```
作为方法的箭头函数this指向全局window对象，
a={c: ()=>{console.log(this)}  a.c()//Window
箭头函数都是在方法内部，总之都是以非方法的方式使用
a={c:function(){var k= ()=>{console.log(this);};  k();}}  a.c()//a对象
```

内联事件中的this指向分两种情况：

1. 当代码被内联处理函数调用时，它的this指向监听器所在的DOM元素
2. 当代码被包括在函数内部执行时，其this指向等同于 ***\*函数直接调用\****的情况，即在非严格模式指向全局对象window， 在严格模式指向undefined

bind方法在ES5引入， 在Function的原型链上， `Function.prototype.bind`。通过bind方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。

变量 `times` 为什么放在外面，就用了一次放在外面，命名冲突了怎么办，或者万一在外面修改了怎么办。[闭包]

在相同的作用域或块级作用域中，不能使用 **let** 关键字来重置 **let** 关键字声明的变量，不同作用域可以。

`const`声明的常量只在当前代码块有效。

通过圆括号调用匿名函数时，把全局参数 window, document和 jQuery 作为参数传到匿名函数中作为局部变量。那么在匿名函数表达式中,`function(w, d, $)`，美元符 **$** 表示 jQuery, 在匿名函数中使用不会导致与外部作用域产生冲突。

除了前两个环境可以获取变量，还有自身原型链继承的属性。

##### 字符串

模板字符串中嵌入变量，需要将变量名写在`${}`之中。反引号。板字符串的大括号内部，就是执行 JavaScript 代码。

**？紧跟在任何量词 \*、 +、? 或 {} 的后面**，将会使量词变为**非贪婪**。【正则】

扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。

**void 运算符** 对给定的表达式进行求值，然后返回 **undefined**

由于undefined并不是一个关键字，其在IE8-浏览器中会被重写，在高版本函数作用域中也会被重写；所以可以用void (0) 来替换undefined【或者阻止事件发生】

很多实践中推荐禁止使用“ ==”，而要求程序员进行显式地类型转换后，用 === 比较。

#### 数据结构

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。

遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。，Iterator 接口主要供`for...of`消费。

由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的

#### Event Loop

（1）所有同步任务都在主线程上执行，形成一个[执行栈](http://www.ruanyifeng.com/blog/2013/11/stack.html)（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

单线程：JavaScript的主要用途是与用户互动，以及操作DOM【同步】。

Web APP VS Native APP 缺点 DOM同步操作   **网页是单线程的**。

#### 模块

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系。ES6在语法上，条件加载就不可能实现。

```
CommonJS 模块就是对象，输入时必须查找对象属性。
// CommonJS模块
let { stat, exists, readfile } = require('fs');
ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。

```

一个模块就是一个独立的文件。

export 用在变量、函数、类的声明处，或者以对象的形式写在最后。

`export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。

`import`命令输入的变量都是只读的，因为它的本质是输入接口。虽然语法上可以更改对象属性的值，其他模块也可以读，排错困难。

都可以通过 as 支持别名，可以在代码任何位置【块级作用域例外】，编译阶段执行，不能使用表达式和变量

`import`语句会执行所加载的模块，`import`语句是 Singleton 模式【多次执行得到一个实例】。

```javascript
import * as circle from './circle';
模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变
```

使用`export default`时，对应的`import`语句不需要使用大括号；并且可以是任意名称。

`export default`命令其实只是输出一个叫做`default`的变量。

模块之间也可以继承。

`import()`类似于 Node 的`require`方法，区别主要是前者是异步加载，后者是同步加载。

默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<script>标签就会停下来，等到执行完脚本。<script>标签打开defer或async属性，脚本就会异步加载。

浏览器对于带有`type="module"`的<script>，都是异步加载

#### 迭代器与生成器

Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象。

因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。

return语句返回的值不会在 for of 语句当中。即属性done为true对应的值。

必须调用遍历器对象的`next`方法，使得指针移向下一个状态。每次遇到`yield`，函数暂停执行

任意一个对象的`Symbol.iterator`方法，等于该对象的遍历器生成函数。

`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。

`for...of`循环可以自动遍历 Generator 函数运行时生成的`Iterator`对象。

ES6 提供了`yield*`表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。任何数据结构只要有 Iterator 接口，就可以被`yield*`遍历。不过是`for...of`的一种简写形式。

ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的`prototype`对象上的方法。

子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。

同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。

普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。

#### 参考文档

- [es6中class类的全方面理解](https://www.jianshu.com/p/86267fab4878)
- 重学前端
- [阮一峰ES6入门](https://es6.ruanyifeng.com/#docs/symbol)
- [帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）](https://blog.csdn.net/cc18868876837/article/details/81211729)
- [闭包](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
- [发布订阅模式/观察者模式](https://www.cnblogs.com/shidengyun/p/5453705.html)
- [JS中的this理解](https://www.cnblogs.com/dongcanliang/p/7054176.html)