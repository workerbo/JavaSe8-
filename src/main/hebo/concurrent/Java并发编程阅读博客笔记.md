

	## Java并发编程阅读博客笔记

### 一：缘由

- 优点

    		充分利用多核CPU的计算能力；
    		方便进行业务拆分，提升应用性能;

- 缺点

    		 频繁的上下文切换:通常减少上下文切换可以采用无锁并发编程[减少一部分不必要的锁竞争带来的上下文切换]，CAS算法，使用最少的线程和使用协程[单线程里实现多任务的调度]。

  ​		线程安全[死锁,同步]，避免死锁的情况：

  1. 避免一个线程同时获得多个锁；
  2. 避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源；
  3. 尝试使用定时锁。    

  

- 概念

  ​    	并发、并行   临界区   同步、异步

### 二、线程状态转换

- 创建线程

  通过继承Thread类，重写run方法；

  通过实现runable接口；

  通过实现callable接口这三种方式

- 线程状态转换

- 线程状态的基本操作【线程间一种通信方式】

  1.  中断：表示一个运行中的线程是否被其他线程进行了中断操作。boolean interrupted() :检测当前线程是否被中断。与isInterrupted不同的是，该方法发现当前线程被中断后会清除中断标志。

      一个线程在未正常结束之前, 被强制终止是很危险的事情. 因为它可能带来完全预料不到的严重后果比如会带着自己所持有的锁而永远的休眠，迟迟不归还锁等。 所以你看到Thread.suspend, Thread.stop等方法都被Deprecated了

     一个比较优雅而安全的做法是:使用等待/通知机制或者给那个线程一个中断信号, 让它自己决定该怎么办。

  2. - interrupt是中断处于阻塞/睡眠状态的线程，退出阻塞状态继续运行。没有占用CPU运行的线程是不可能给自己的中断状态置位的。这就会产生一个InterruptedException异常。

     * 中断正在运行的线程设置中断标志。被中断线程可以决定如何应对中断

  3. join方法可以看做是线程间协作的一种方式，很多时候，一个线程的输入可能非常依赖于另一个线程的输出。

  4. sleep()方法只是会让出CPU并不会释放掉对象锁；wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。

  5. yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。

### 三、JMM与happens-before

- 线程安全：当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

- 出现线程安全的问题一般是因为**主内存和工作内存数据不一致性**和**重排序**

- 多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到**多个线程间相互通信告知彼此的状态以及当前的执行结果**等

- 线程协作的方式：1）共享变量 2）等待通知 3）中断

- 并发编程中主要需要解决两个问题：**1. 线程之间如何通信【共享内存和消息传递】；2.线程之间如何完成同步【控制不同线程间操作发生的相对顺序】**

- JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。

- **为了提高性能，编译器和处理器常常会对指令进行重排序** 【不存在数据依赖性】 在多线程状态下可能会导致问题

- happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，**JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证**

- 从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。【happens-before关系并不代表了最终的执行顺序。只是逻辑顺序。如果结果一致允许重排序】。

  总结：1. JMM的抽象结构（主内存和线程工作内存）；2. 重排序以及happens-before规则。

参考文档：

