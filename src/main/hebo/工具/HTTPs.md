- 对称加密：

  - 加密和解密都是用同一个密钥

- 非对称加密：

  - 加密用公开的密钥，解密用私钥
  - (私钥只有自己知道，公开的密钥大家都知道)

- 数字签名：

  - 验证传输的内容**是对方发送的数据**
  - 发送的数据**没有被篡改过**

- 数字证书（Certificate Authority）简称CA

  - 认证机构证明是**真实的服务器发送的数据**。

  一般情况下用非对称加密交换对称加密的密钥。信息传输需要 保密性【】、完整性【数字签名】、合法性【数字证书】

3y的通讯之路：

- 远古时代：3y和女朋友聊天传输数据之间没有任何的加密，直接传输

  

- 上古时期：使用对称加密的方式来保证传输的数据只有两个人知道

  - 此时有个问题：**密钥不能通过网络传输**(因为没有加密之前，都是不安全的)，所以3y和女朋友先约见面一次，告诉对方密码是多少，再对话聊天。

- 中古时期：3y不单单要跟女朋友聊天，还要跟爸妈聊天的哇(同样不想泄漏了自己的通讯信息)。那有那么多人，难道每一次都要约来见面一次吗？(说明维护多个对称密钥是麻烦的！)--->所以用到了非对称加密

  - 3y自己保留一份密码，独一无二的(私钥)。告诉3y女朋友，爸妈一份密码(**这份密码是公开的，谁都可以拿**--->公钥)。让他们给我发消息之前，先用那份我告诉他们的密码加密一下，再发送给我。我收到信息之后，用自己独一无二的私钥解密就可以了！【公钥加密，私钥解密】【双向非对称加密】

- 近代：此时又出现一个问题：虽然别人不知道私钥是什么，拿不到你原始传输的数据，但是可以拿到加密后的数据，他们可以改掉某部分的数据再发送给服务器，这样服务器拿到的数据就不是完整的【因为公钥公开，可以直接替换掉密文，接受者正常解密】

- 现代：拿到的数据可能被篡改了，我们可以使用数字签名来解决被篡改的问题。数字签名其实也可以看做是**非对称加密的手段一种**，具体是这样的：得到原信息hash值，用**私钥**对hash值加密，**另一端**用**公钥**解密，最后比对hash值是否变了。如果变了就说明被篡改了【私钥对hash加密，公钥解密】

- 目前现在：我们对签名进行验证时，需要用到公钥。如果公钥也是伪造的，那怎么办？如果公钥是假的，验证数字签名那就无从谈起，根本不可能从数字签名确定对方的合法性。【中间人用替换了公钥后，用对应的私钥进行签名，此时也验签通过】

HTTPs

服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。

客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。

如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。



tomcat、nginx可以配置数字证书。



MD5是一种不可逆的加密方式，称为散列【不能被解密】，用户注册的时候，数据库中存入的不是明文密码，也不是简单的对明文密码进行散列，而是 MD5( 明文密码 + Salt)。

是不是加了 Salt 之后就绝对安全了呢？淡然没有！坏人们还是可以他们数据字典中的密码，加上我们泄露数据库中的 Salt，然后散列

实际项目中，Salt 不一定要加在最前面或最后面，也可以插在中间嘛，也可以分开插入，也可以倒序，程序设计时可以灵活调整，都可以使破解的难度指数级增长

http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html

