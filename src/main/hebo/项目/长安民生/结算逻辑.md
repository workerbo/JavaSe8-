### HSCS记录

其他系统重复推送数据批次号必须不同

hscs结算主产品、hitf结算规则、hscr结算规则、hsca会计引擎

###### hap

LOV前端描述需要后端转换【关联lov表lov_item】

codeCache.getValue(codeName+"."+"zh_CN").getCodeValues();

获取规则头list

将规则明细信息从缓存中取出

如果筛选组存在，则将筛选组工具类放进规则头里

将未启用的移除

如果生成规则为取值方式公式,则将公式明细信息缓存



#### 修正记录

票据管理-取消关联  一：事务处理有问题，A无事务方法调用B有事务方法。B不会被事务增强。1）A获取的connection会自动提交。2）B方法也没有通过代理对象调用。二，空指针处理

项目代码自定义：

#### 逻辑备注

销售单、订单--中间表【根据需要建表和字段、生产规则处引用】--结算单

hitf.itf.service.impl.ItfImpExcelDataServiceImpl#saveAllNumbers：按照顺序，将Excel的数据插入Interface表中

通过序号连接值和方法。通过反射赋值

结算平台：来源表-中间表【接口定义】  中间表-结算头行表【中间表配置】  生成规则配置汇总和取值逻辑





部分描述维护没有

CaffeineCache

redis的键名和配置文件中的bean名有关。







组件控制！！！

前端参考样式可以在启动项目后在，项目url后面+test.html查看

建议在超链接的a标签中加上 javascript:void(0), 加了javascript:void(0)点击a标签后页面如果太长不会发生变化还在点击的部位;不加直接#的话页面太长会回到页面的头部，而且有些浏览器会存在没有鼠标手的状态

快捷键参照期间开闭页面。

前端页面快码聚合。

##### 接口平台



/api/public/imp-data/simple-data通过这个restful接口导入数据

接口表接收到数据【一个批次对应一个接口】，先拆分成接口头行表，头表先插入数据库【并获取配置校验数据】、在对映射列和自定义来源列转换，再进行校验，最后插入行表【每千行批次】（中间即使校验出错也错插入到行表当中）。

自定义来源:传入值不需要对应，在配置处映射到源列或者映射列。传出值选择接口定义处的自定义来源列字段。

生成规则头 存接口定义的头id  存筛选组id    行存接口定义行的行ID【字段来源是源列、映射列、自定义来源列】

生成规则 的程序包必须实现ItfImpPackageListener

生成规则明细需要引用映射列，防止被映射被删除

```
applicationContext.getAutowireCapableBeanFactory().autowireBean(packageListener)
```

IItfImportRelationListener  导入目标表的监听器

接口定义冻结触发任务

根据接口对应的生成规则

接口头金额的计算，通过double级别【Arith工具类】进行计算，在报错到数据库的时候只有两个小数位。

#### HSCR

 三个job自动执行全过程

 scs.job.AutoArCrJob

scs.job.CrValidateJob

scs.job.CrImpJob

中间表用于通过生成规则从接口头行到目标业务表的中间停留，用户汇总

接口定义处的TAG设置这个接口的数据来源表和字段。通过来源表h.status_code = 'APPROVED'
AND h.purchasing_source = 'BMS'进行判断。

计算程序

SequenceUtil 分布式线程安全的获取唯一序号

AutoApCrJob 从源表导入到接口头表

计划任务中的事务控制

##### HSCS技术点

1. [CXF发布RestFul WebService和SOAP WebService](https://blog.csdn.net/weihao_/article/details/72865028)
2. Quartz实现定时任务组件
3. 消息驱动的后台任务
4. 06 程序交接文档（重）

##### HSCS代码疑点

1. 通过定时Ajax得到进度
2. 主从复制

##### 源码阅读技巧

1.第一遍调用逻辑，第二遍实现方式，第三遍时序图和类图



结算规则的生成规则和接口平台的生成规则区别：结算规则的生成规则由于中间表的配置，一个生成规则同时生成规则。同时通过分组方式区分头行。



> ##### ITF组件逻辑
>

拆分-验证【有job自动执行】-导入 【job】

1.接口定义编辑：验证值集【可以缓存】、验证快码      映射值集【可以缓存，LOV过大就走数据库查询、加索引】

```
                        自定义来源和映射在校验之前前处理【结算规则是在导入时进行转换】

                         接口冻结是通过执行任务执行

                    任务：实现ITask接口
```

2.数据导入：下载模板（自动生成对应接口的Excel模板）

```
      从外部导入的时候要判断是否在接口中定义，然后才插入到表中
```

3.导入数据查询【接口数据头行表】

4.历史头行表记录对应批次的操作时间、结果、类型、形式

![image-20200923142803467](https://gitee.com/workerbo/gallery/raw/master/2020/运行日志ITF.png)

5.ItfDtoRefUtils  asm字节码技术



Q&A

1.从接口行表到业务表【生成】、为啥要分源、映射、自定义？

映射【自定义来源】删除时需要检查是否被生成规则引用。

2.结算单在接口平台和结算规则都生成了一次？

不是，从接口导入的数据是否可以直接导入到业务表。【AR、AP接口直接进入业务表，不经过结算规则】

计划任务 

 手动导入：解析每行数据的时候去掉前2列(接口名称和来源系统),然后通过valueSeqMap.get(序号)得到对应的方法,然后通过反射将值set到ItfImpInterfaces对象,最后批量插入到数据库。

 区别



技术点

1.kafka  【缓】

2.计划任务 【多个节点的处理】、任务 

3.多线程

在有更改的情况，注意刷缓存或者执行对应的任务







> 对账单功能目录

1. 生成规则匹配、生成规则定义

   - 生成规则获取：

     ```
     hscs.ar.service.impl.ArSettleOrdersServiceImpl#getDynamicCondition
     ```

   - 生成规则头之间或的关系。没有生成规则，就不会用生成规则匹配中的字段，要在生成规则头中指定生成规则匹配字段的值。行上条件类别相邻相同为或关系，不然为且关系。

2. 分组规则匹配、分组规则定义【先匹配再分组】

   - 通过分组字段、分组字段的值进行java逻辑上的分组。然后再通过结算单分组的字段和对应的值匹配分组规则头。**找不到匹配头还会报错**。

   -  在分组规则行规则中加入强制分组的三个规则，页面已经控制选不到SIGN_COMPANY、CURRENCY_ID、PARTY_SITE_ID。

   - 账单会记录分组规则匹配字段对应结算单的值。

   - 对分完组后的结算单进行生单,一单一结的结算单组无需分组可以直接调用该方法生单

     ```
     hscs.ap.service.impl.ApPoSettleOrdersServiceImpl#handStatements(com.hand.hap.core.IRequest, java.lang.String, java.lang.String)手动生单和自动生单进入分组生成账单
     hscs.ar.service.impl.ArSettleOrdersServiceImpl#generateRecByGroupedList对账单的生成
     ```

     

3. 手工创建对账单  创建对账单规则和满足条件

   - 生单查询结算单必须满足的条件：1.状态已审批2.还有对账金额 3.对应的合作伙伴支持对账。4.结算类型

4. 自动创建对账单  自动生单规则和满足条件

   -  不受查询界面筛选条件的限制，根据时间限制【创建时间、计划对账日期】和结算周期生成对账单；【也要受生成条件限制】
   - 结算周期：主要排除一单一结的情况
   - 非一单一结根据公司分批【数据量比较大】【用闭锁让主线程等待其他任务线程执行完毕】

5. 非汇总对账单调整、审批、取消流程

6. 汇总对账单创建、调整、审批、取消流程

7. 账单核对

   1. 对账单
      - 账单撤销【结算单需要调整、例如复核驳回、客户驳回】之后需要重新生成账单
      - 
      
   2. 账单核对-模板定义[账单或者订单]
      
      - 头行数、尾行数【头尾去除】
      
   3. 客户/供应商选择对应模板导入数据
   
   4. 新建核对规则账单核对
   
   5. 账单核对
      
        核对：内外【一对多，一是内还是外部系统】、单据类型、匹配方式
      
      1. 自动核对  /hscs/ar/check/auto
      
           hscs.ar.mapper.ArImpLinesMapper#getImpDataForCheck
      
         oneDataType          一对多或者多对一或者一对一中的一条数据的类型，"out"或者"in"
      
           规则行分为分组【优先分组】和汇总两部分【用于区分多对多、多对一、一对一】
      
         一对一（out）：根据并集标识分组，拼接过滤条件【匹配方式为常数时才会拼接动态过滤条件，其他方式拼接动态字段】
      
         核对规则外围字段在前且匹配方式为常数则是过滤外围数据行的。其余方式是过滤系统单据的。
      
         每一个外围数据行去匹配一个对账单或者对应的结算单行。【过滤条件：客商ID、客商地点id【外围数据行不为null才过滤】、货币id】
      
           多对一：遍历分组和对规则，将需要查询的字段拼接到动态字段中。只会有两种情况，一种是公式，一种是字段匹配
      
         前端页面：
      
         当字段以及匹配字段的类型为数值，或者匹配方式为公式时，汇总允许变为Y
         
         存在分组行时，必须有汇总行
         
      2. 合并对账单
      
            合并的对账单必须满足分组条件【分组字段有一样的值】，通过分组规则ID查找强制分组为Y的字段名



> ##### 问题

1. 结算单会部分对账？
2. 手动分组在查询的时候强制了三个条件？但是自动生单的时候是在其有分组规则才会强制加。
3. 字段处理【结算类型、计划对账日期、结算周期、业务单元、确认状态】
4. 审批和复核流程流程冲突
5. 复核、客户审核没有进行记录【待确定】
7. [x] 部分显示格式【汇总账单的子账单显示】

- [x] 在没有分组规则的时候 ，  手动生单多个结算单。

```
/hscs/ar/service/impl/ArSettleOrdersServiceImpl.java:1462
 boolean boo3 = businessUnit1.equals(businessUnit2);
```



- [x]    汇总账单添加子账单时空指针。

```
/hscs/ar/controllers/ArCustRecRelationsController.java:305  空指针异常
```