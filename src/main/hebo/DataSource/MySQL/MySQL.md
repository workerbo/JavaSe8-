##### MySQL

[mysql锁问题【重要】](https://www.cnblogs.com/boblogsbo/p/5602122.html)

1.SQL[执行顺序](https://database.51cto.com/art/201911/605471.htm)

2.**GROUP BY 配合CUBE 和 ROLLUP**显示更多层次的分组

3.执行SQL后执行show profile得到执行时间

4.SQL[优化](https://blog.csdn.net/jie_liang/article/details/77340905)。要点是使用索引，避免全表扫描

5.多表查询后排序慢【排序字段已经有了索引】，但是myql会自动根据小表驱动大表进行优化【驱动表才能使用索引，导致排序索引失效】，所以可以将join变成到select的子查询

6.MySQL可以运行不同的SQL Mode（SQL模式）下。SQL Mode定义了MySQL应支持的SQL语法、数据校验等，

7.只是对某些语句需要进行事务控制，则使用START TRANSACTION语句开始一个事务比较方便，这样事务结束之后可以自动回到自动提交的方式

8.MySQL 的外键功能仅对 InnoDB 存储引擎的表有作用，其他类型存储引擎的表虽然 可以建立外键，但是并不能起到外键的作用。

9. MySQL 最常用的 4 种日志类型：错误日志【默认开启】、二进制日志、查询日志和慢查询日志。
10. mysql的innodb引擎支持行锁，事务，外键。MyISAM支持表锁，串行执行【读锁写锁互斥】。
11. ，MyISAM 总是一次获得 SQL 语句所需要的全部锁。【表锁不会死锁】
12. InnoDB 的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB 会使用表锁。
13. innoDB并发执行导致的问题【多个事务可以交叉执行】
14. 更新丢失可以通过乐观锁或者悲观锁解决。读取问题通过读之前加锁或抓MCC解决
15. 在mysql设置了自动提交之后可以通过语句start  transaction开启手动提交。【事务启动手动提交或者回滚，会释放同一会话中的锁】
16. 在用范围条件更新记录时，无论在 Read Commited 或 是 Repeatable Read 隔离级别下，InnoDB 都要使用**间隙锁【不允许出现幻读】**。
17. MySQL 的恢复是 SQL 语句级的，MySQL的 Binlog是按照事务ᨀ交的先后顺序记录的，恢复也是按这个顺序进行的。在一个事务未ᨀ交前，其他并发事务不 能插入满足其锁定条件的任何记录，也就是不允许出现幻读
18. 在不同的隔离级别下【还有数据恢复和复制机制】，InnoDB 处理 SQL 时采用的一致性读策略和需要的锁是不同的。
19. 对于许多 SQL，隔离级别越高，InnoDB 给记录集加的锁就越严格（尤 其是使用范围条件的时候），产生锁冲突的可能性也就越高，从而对并发性事务处理性能的 影响也就越大。因此，我们在应用中，应该尽量使用较低的隔离级别，以减少锁争用的机率。
20. 在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则 MySQL 不会给表加锁；事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES 会隐含地ᨀ交事务；COMMIT 或 ROLLBACK 并不能释放用 LOCK TABLES 加的表级锁，必须用 UNLOCK TABLES 释放表锁
21. MyISAM 总是一次获得所需的全部锁， 要么全部满足，要么等待，因此不会出现死锁。但在 InnoDB 中，除单个 SQL 组成的事务外， 锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。
22. 发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得 锁，继续完成事务【行锁】
23. 涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测 到死锁，这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决
24. 对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及数据集加排他锁（X)；对于普通 SELECT 语句，InnoDB 不会加任何锁；事务可 以通过以下语句显示给记录集加共享锁或排他锁。对于锁定行记录后需要进行更新操作 的应用，应该使用 SELECT... FOR UPDATE 方式获得排他锁。
25. MySQL 的字符集和校对规则有 4 个级别的默认设置：服务器级、数据库级、表级和字 段级。同时客户端、连接和返回结果的字符集
26. MySQL 中，参数的初始化是通过参数文件来进行设置，当参数需要修改时，可以选择以下 3 种修改方式。session 级修改（只对本 session 有效）。全局级修改（对所有新的连接都有效,但是对本 session 无效，数据库重启后失效）。永久修改。将参数在 my.cnf 中增加或者修改，数据库重启后生效。
27. SHOW VARIABLES 和 SHOW STATUS 命令查看 MySQL 的 服务器静态参数值和动态运行状态信息。其中前者是在数据启动后不会动态更改的值，比如缓冲区大小、字符集、数据文件名称等；后者是数据库运行期间的动态变化的信息，比如锁等待、当前连接数等。同时可以通过select查看变量。
28. 通过备份和binlog实现完整的恢复
29. 比较使用 EXISTS 和 IN 的查询。注意两个查询返回相同的结果。
    select * from TableIn where exists(select BID from TableEx where BNAME=TableIn.ANAME)
    select * from TableIn where ANAME in(select BNAME from TableEx)
30. Navicat连接[Oracle](https://blog.csdn.net/gxp1182893781/article/details/79815573)
31. PLSQL[安装](https://www.cnblogs.com/zhangchao0515/p/11353868.html)
32. 客户端显示Oracle数据库的数据乱码
33. select * from  hceb_ce_banks_v
     select * from V$NLS_PARAMETERS 
     NLS_LANGUAGE 表示“语言”，NLS_TERRITORY  表示“地域”，NLS_CHARACTSET 表示“字符集”，将他们三个按照“语言_地域.字符集”的格式拼接起来



> 锁的概念

###### MySQL上的锁

排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select ...for update语句，加共享锁可以使用select ... lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。锁是加在索引上的。

###### 悲观锁【逻辑上的概念】

因为悲观锁会影响系统吞吐的性能，所以适合应用在写为居多的场景下。

###### 乐观锁【逻辑上的概念】

因为乐观锁就是为了避免悲观锁的弊端出现的，所以适合应用在读为居多的场景下。

在保证逻辑正确的情况，乐观锁是指没有其他事务会争抢，然后不提前加锁的更新。悲观锁指的是会有其他事务争抢，提前锁定资源去更新。  mysql引擎自动给增删改加的锁是保证多个事务的更新有序，确保可见。

查询的时候是锁住，还是获取版本号

查询的时候是锁住【适合于写】，还是获取版本号【适合于读】

乐观锁因为时通过我们人为实现的，它仅仅适用于我们自己业务中，如果有外来事务插入，那么就可能发生错误。【即其他事务没有加版本号去更新】



###### 数据库隔离级别实现

为了实现可重复读，MySQL 采用了 MVVC (多版本并发控制) 的方式。

数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id

在上面介绍读提交和可重复读的时候都提到了一个词，叫做快照，学名叫做一致性视图，这也是可重复读和不可重复读的关键，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。

对于一个快照来说，它能够读到那些版本数据，要遵循以下规则：

1. 当前事务内的更新，可以读到；
2. 版本未提交，不能读到；
3. 版本已提交，但是却在快照创建后提交的，不能读到；
4. 版本已提交，且是在快照创建前提交的，可以读到；



READ UNCOMMITTED(RU) ： 对于修改的项加排它锁，直到事务结束释放；没有快照读，只能读最新版本的数据。

READ COMMITTED(RC) ：对于修改的项加排它锁，直到事务结束释放；有快照读，快照的粒度是语句级。

REPEATABLE READ(RR) ：对于修改的项加排它锁，直到事务结束释放；有快照读，快照的粒度是事务级。【MySQL通过Next-key【行锁和Gap lock解决幻读】】

并发写通过行锁保持先后顺序。通过乐观锁【update更新失败，返回0】或者悲观锁【保证读取到最新的数据，一次更新成功】策略保证**当前读**是最新版本的数据。

隔离级别：事务一致性、锁：