# 1. 事务基础

## 1.1 事务的特性

A-原子性；C-一致性；I-隔离性；D-持久性。
 MySQL中，事务的原子性、一致性、隔离性是由MVCC + 锁 + undo log保证的，持久性是由binlog、redo log保证的。

##### 事务 ACID

ACID：事务的四大特性原子性、一致性、隔离性、持久性。
原子性：原子性是指一个事务要么全部执行，要么完全不执行。主要是由 innodb 引擎中的 undo 回滚日志来维护。
隔离性：事务在操作过程中不会受到其它事务操作的影响。主要由事务的隔离级别和锁机制共同维护。
持久性：事务操作的结果是具体持久性的，通俗来讲就是提交事务后会持久化存储(落盘)。主要是由 redo log 来维护。
一致性：事务在开始和结束时，数据始终保持一致。由原子性、隔离性、持久性共同维护。

## 1.2 事务面临的问题

| 问题       | 解释                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏写       | 一个事务修改了另一个事务还未提交的数据                       |
| 脏读       | 一个事务读取了另一个事务还未提交的数据                       |
| 不可重复读 | 一个事务中，相同的条件多次读取的值不同（其他事务在中间时刻提交了修改的数据） |
| 幻读       | 一个事务中，相同的条件多次读取的结果数量不同（其他事务在中间时刻提交了新增的数据） |

## 1.3 事务的隔离级别

事务的隔离级别有四种：`READ UNCOMMITTED`、`READ COMMITTED`、`REPEATABLE READ`、`SERIALIZABLE`。MySQL分别使用了哪些技术来实现这四种隔离级别呢？看下表格：

|                                  | READ（读）    | WRITE（写）   | 可能的问题                                                   |
| -------------------------------- | ------------- | ------------- | ------------------------------------------------------------ |
| **READ UNCOMMITTED（未提交读）** | -             | X锁（排他锁） | 脏读、不可重复读、幻读                                       |
| **READ COMMITTED（已提交读）**   | MVCC          | X锁（排他锁） | 不可重复读、幻读                                             |
| **REPEATABLE READ（重复读）**    | MVCC          | X锁（排他锁） | 幻读（理论上MqSQL可重复读通过间隙锁和MVCC也解决了绝大多数幻读的情况） |
| **SERIALIZABLE（序列化读）**     | S锁（共享锁） | X锁（排他锁） | -                                                            |

> 问：为什么四种隔离级别下的写操作都需要加排他锁？
>  答：无论什么隔离级别，写操作都是要隔离的，否则就会发生**脏写**。而脏写是任何数据库都无法接受的情况。所以**写操作必须加排他锁。**

> 问：已提交读和重复读隔离级别都是采用的MVCC+排他锁实现的，他们的区别在哪？
>  答：简单来讲就是读的时候MVCC会生成一个ReadView结构，两者的区别就在于这个ReadView结构生成的时机不同。已提交读会在事务中每次读请求触发时重新生成ReadView结构，而重复读只会在事务中第一次读请求时生成ReadView结构。详细情况见下面的MVCC详情介绍部分。

## 1.4 事务ID

MySQL中只有涉及写的事务才会分配事务ID，在事务第一次执行写操作时分配。否则事务的事务ID默认为0.

> 问：事务ID是如何分配的？
>  答：InnoDB引擎维护了一个`max_trx_id`全局变量，这个就是下一次待分配的事务ID。当一个事务需要被分配一个事务ID时，就会获取`max_trx_id`的值，然后`max_trx_id`加1. 所以MySQL理论上事务ID是全局严格递增的。

> 问：在实践中发现，事务ID不是连续的，什么情况下会导致事务ID不连续？
>  答：`update`和`delete`操作除了事务本身的操作外，还涉及旧数据的标记删除。这个删除动作是放在队列里面异步删除的，删除旧数据也会把`max_trx_id`加1，所以自己测试时会观察到事务ID不连续的情况。

> 问：为什么InnoDB引擎设计为只读事务不会生成事务ID？
>  答：两个原因。
>
> - 减少ReadView中活跃事务ID列表的大小。MVCC会依赖ReadView结构，其中会保存当前活跃的事务ID，数据库一般读远大于写，所以只读事务不分配事务ID会大大减少ReadView结构数据量，提高MVCC执行效率（ReadView作用见下文MVCC）。
> - 减缓`max_trx_id`增长速度。MySQL为事务ID分配的空间是固定大小的，`max_trx_id`上限是2^48-1，理论上只要一个MySQL服务运行时间足够久，就可能出现`max_trx_id`超过上限从0开始的情况。这样理论上会出现脏读的bug。

## 1.5 事务提交

从客户端的角度来讲，我们执行`commit`命令完成事务提交。从InnoDB引擎层面讲怎样算是提交一个事务呢？答案是 `redo log` 和 `binlog`。
 一条写命令执行时是先写 `redo log` 再写 `binlog` 的，`binlog` 写完再在 `redo log` 中追加 `commit` 显式提交事务。但是 `redo log` 中的 `commit` 并不是必须的。比如数据库崩溃恢复过程中（MySQL是根据 `redo log` 做崩溃恢复的），如果判断 `binlog` 是完整的，则该事务对应的 `redo log` 必然是完整的，即使没有 `commit`，也会恢复此事务数据。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df853d3c2b9b4464aba78980f6d89d50~tplv-k3u1fbpfcp-watermark.awebp?)

注意：这里 `redo log` 写 `commit` 可以不刷盘，原因就是可以跟着下一次事务数据一起刷盘。就算丢失这个 `commit` 也无妨，因为 `binlog` 是完整的话这个事务就可以被认为是提交状态了。

> 问：为什么MySQL中一个事务是否提交要用日志判断？MySQL恢复也用日志恢复？MySQL中的各种日志的作用是什么？
>  答：MySQL 中关键的日志包括 `redo log`、`binlog`、`undo log`。每种日志的详细介绍见下文日志部分。这里简单提一下就是MySQL为了减轻直接磁盘读写页面的压力，引入了 `Buffer Pool` 作为缓冲，对页面的修改不会直接刷新到磁盘。但是这样的话就可能因突然崩溃丢失数据。为了解决这种问题，引入了 `redo log` 和 `binlog`。`redo log` 保存的是对页面的修改、`binlog` 保存的是执行的语句，如果这两种日志完整，则事务可提交。因为即使数据库崩溃 `Buffer Pool` 中的页面没有刷新到磁盘，也可以根据这两种日志中的内容恢复。

> 问： 为了减少Page刷磁盘的次数，而引入了两次日志刷磁盘，提升效率明显吗？
>  答：肯定的。第一：日志是顺序写，页面是随机写。顺序写磁盘比随机写磁盘性能是数量级的差别。第二：Page页面是固定16K，一个更新语句可能涉及十几个页面（涉及多条记录、多个索引树等），而日志则不存在这个问题。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3bf43b74e314449b0e09ce24b52ccfd~tplv-k3u1fbpfcp-watermark.awebp?) 注意：图中从Buffer Pool刷盘到磁盘页面是异步刷盘的，或者淘汰页面时会刷盘。极端情况下比如`redo log`文件写满无法释放才会主动刷盘。平常事务提交是不会从Buffer Pool刷页面到磁盘的。而事务提交一定是 `redo log` 和` bin log` 写到了磁盘文件后的动作（当然如果设置的刷盘策略不是每次事务提交必刷盘的话，还是可能会在极端情况下丢失数据的）。

> 问：图中的 `change buffer` 是什么作用？
>  答：是进一步减少磁盘I/O提升效率的手段。假设这样一个场景：一个更新语句需要修改Page10的一行数据，但这个Page并没有被加载到`Buffer Pool`，如果没有`Change Buffer`，则需要从磁盘读取Page10到`Buffer Pool`，然后修改这一行记录。虽然并不需要将Page10刷回磁盘（当然是`redo log`和`binlog`提供了持久化保证啦），但还是需要读取磁盘。`Change Buffer`的作用是如果这个页面不在`Buffer pool`中，无需读取磁盘，直接将要修改的页面和修改的内容暂存到`Change Buffer`，这样连读取的磁盘I/O也节省了。等后续Page10被加载到`Buffer Pool`后，从`Change Buffer`中merge一下修改就可以。
>  那么可能就有人有疑问了：那 `Change Buffer` 也是在内存中存储的，它是怎么做到持久性保证的呢？ 答案很简单：`Change Buffer` 内部也是以Page页面的形式存储数据的，也会写对应的`redo log`和`binlog`。

# MVCC

理解了版本链、ReadView结构，就理解了MVCC。

## 版本链

版本链主要依赖MySQL行数据中的两个隐藏列：`trx_id`和`roll_pointer`。通过这两个隐藏列再加上`undo log`中存储的数据实现数据的版本链功能。

- trx_id：事务ID，就是上文介绍的事务ID，每次一个事务对某条记录进行改动时，都会把该事务的事务id赋值给`trx_id`隐藏列。
- roll_pointer：每次对某条记录进行改动时，都会把此记录旧的版本写入到`undo日志`中，然后`roll_pointer`就相当于一个指针，可以通过它来找到该记录修改前的信息。

我们可以想象成通过`roll_pointer`列把这条记录的所有版本记录串联成了一个链表，链表头部就是该记录的最新版本。同时，记录的所有版本都保存着使自己变成当前状态的事务ID：`trx_id`。
 *当然并不是该记录的所有历史版本都会永久保存，满足一定条件后MySQL会清理无用的`undo log`。*

## ReadView 结构

ReadView 结构主要包含4部分：

| 字段           | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| m_ids          | 生成本ReadView时刻活跃事务ID列表                             |
| min_trx_id     | 生成本ReadView时刻最小活跃事务ID（m_ids中的最小值）          |
| max_trx_id     | 就是上文中**事务ID**部分讲的`max_trx_id`全部变量（下一次待分配的事务ID） |
| creator_trx_id | 顾名思义，生成本ReadView的事务ID                             |

通过ReadView判断该版本数据是否对自己可见：

- 如果当前记录的`trx_id`和ReadView中`creator_trx_id`相同，说明此记录是本事务最近修改的，本着事务内的修改对自己可见的原则，此纪录可见。

- 如果当前记录的`trx_id`小于ReadView中`min_trx_id`，说明本事务生成ReadView时，修改记录的事务早已提交，此纪录可见。

- 如果当前记录的`trx_id`大于等于ReadView中`max_trx_id`，说明本事务生成ReadView时，修改记录的事务还未出现，肯定是在自己的事务生成之后修改的，此纪录不可见。

- 如果当前记录的

  ```
  trx_id
  ```

  大于ReadView中

  ```
  min_trx_id
  ```

  小于ReadView中

  ```
  max_trx_id
  ```

  ，则需要进一步判断当前记录的

  ```
  trx_id
  ```

  是否在

  ```
  m_ids
  ```

  列表中：

  - 如果在，则说明生成ReadView时那个事务还未提交，则记录不可见；
  - 如果不在，则说明生成ReadView时那个事务已经提交，则记录可见。

MySQL根据 **ReadView结构 + 版本链** 实现事务读取操作的步骤如下：

1. 生成或获取ReadView结构；
2. 读取记录的最新版本；
3. 通过ReadView判断该版本数据是否对自己可见；
4. 如果可见，返回此版本的记录，结束。如果不可见，根据`roll_pointer`指针沿着版本链向下查找记录。重复步骤3、步骤4.

> 问：举个例子。
>  答：当前系统中活跃的事务ID有：587，678，874，667，全局变量`max_trx_id`为1024。此事务目前没有执行写操作。那么生成的ReadView结构如下：
>
> - m_ids：{587，678，874，667}
> - min_trx_id：587
> - max_trx_id：1024
> - creator_trx_id：0
>
> 现状：此事务要读取的行的版本链如下：
>  874 -> 586 -> 220 -> 219
>  分析：874大于587小于1024，且在`m_ids`列表中，此纪录不可见，沿着版本链找到586版本的记录，586记录大于587小于1024，但不在`m_ids`列表中，此纪录可见。

> 问：MVCC是如何实现读提交和重复读的？
>  答：生成ReadView结构的时机不同。
>
> - 读提交的隔离级别下，在事务中，每次进行查询前，都会重新生成新的ReadView结构，如果在两次查询中间其他事务提交了修改，则本事务生成的ReadView结构会不同。
> - 重复读的隔离级别下，在事务中，只会在第一次查询前生成一次ReadView结构，后续查询不会重新生成。根据上面流程的介绍，如果ReadView结构不变，对版本链中不同版本的数据是否可见的评判标准就不变，这样即使有其他事务在中间提交了更改，这个新的更改也对本事务不可见，所以可以实现重复读。
> - 注意：仅仅开启事务是不会生成ReadView结构的，只有在第一次执行查询时才会生成ReadView结构。

# 锁

MySQL中和事务有关的主要是行锁，其他类型的锁这里简单提一下。

## 表锁

| 锁分类          | 解释                                                         |
| --------------- | ------------------------------------------------------------ |
| 共享锁 S        | 也叫读锁。作用于表级别。一般用不到。                         |
| 排他锁 X        | 也叫写锁。作用于表级别。一般用不到。                         |
| 意向共享锁 IS   | 声明：IS之间、IS和IX之间都是兼容的，不存在竞争关系。此锁可认为只是一个标志。这里需要和行锁做联动了：如果要在表中记录上加S锁，需要先在表上加IS锁。为什么呢？有了IS锁，如果需要在表上加X锁，可以快速判断表中记录上当前存不存在X锁，存在则无法在表上加X锁。 |
| 意向排他锁 IX   | 声明：IX之间、IS和IX之间都是兼容的，不存在竞争关系。此锁可认为只是一个标志。这里需要和行锁做联动了：如果要在表中记录上加X锁，需要现在表上加IX锁。为什么呢？有了IX锁，如果需要在表上加S锁，可以快速判断表中记录上当前存不存在S锁，存在则无法在表上加S锁。 |
| 自增锁 AUTO-INC | 如果用到了MySQL的自增id功能，MySQL会维护一个自增值作为自增id（MySQL 8.0 会在redo log持久化这个值；之前版本只是在内存中维护，重启需要读取当前表中最大值然后重新设置）。获取这个值需要使用自增锁AUTO-INC。注意一点：自增锁是获取成功即释放的，如果语句执行失败如唯一键冲突或者事务回滚，自增id是不会回退的。 |

## 行锁

行锁作为一个数据结构，其包括的信息如下：

- 锁所属的事务信息（锁是归属于某一个事务的，即是哪个事务给这一行加的锁）
- 锁所属的索引信息（锁是归属于某一个索引的，即是给哪棵索引树上的行记录添加的锁。举个例子，一张表除了聚簇索引外，还有三个二级索引，那么如果要更新这张表某行的所有字段，势必需要创建四个锁结构，分别对应四个索引）
- 锁信息（表锁？行锁？...）
- 锁类型（记录锁？间隙锁？共享？排他？...）
- 锁定的行记录（该锁作用于哪些行。）

> 例子：当前表中有7条记录，分别为{1，4，8，13，25，63，87}
>
> - 在
>
>   重复读的隔离级别
>
>   下执行语句：
>
>   ```
>   select * from table where id > 13 and id < 63 for update;
>   ```
>
>   - MySQL会在记录25上添加`Next-Key Locks X`，在记录63上添加`Gap Locks X`。
>   - 如果此时另一个事务要读取记录25，会在记录25上添加`Record Locks S`然后阻塞等待。
>   - 如果此时另一个事务要插入记录24，则会在记录25上添加`Insert Intention Lock`阻塞等待。
>
> - 在
>
>   读提交的隔离级别
>
>   下执行语句：
>
>   ```
>   select * from table where id > 13 and id < 63 for update;
>   ```
>
>   - MySQL只会在记录25上添加`Record Locks X`。
>   - 如果此时另一个事务要读取记录25，会在记录25上添加`Record Locks S`然后阻塞等待。
>   - 如果此时另一个事务要插入记录24或者26，都可以直接插入成功。

| 锁分类                              | 解释                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| Record Locks（记录锁）              | 可以细分为共享锁和排他锁。`Record Locks`只会锁某一行。例如我在记录25上面加了`Record Locks` 排他锁，那么其他事务无法修改25这条记录，但是可以插入记录24，也可以插入记录26。 |
| Gap Locks（间隙锁）                 | 可以细分为共享锁和排他锁。`Gap Locks`锁的是间隙。例如我在记录25上面加了`Gap Locks` 排他锁，那么其他事务无法插入14 ~ 24的记录，但是可以修改25这条记录。注意：在重复读的隔离级别下才会使用`Gap Locks`，读提交只会使用`Record Locks`。 |
| Next-Key Locks                      | 可以细分为共享锁和排他锁。相当于`Record Locks`和`Gap Locks`的合体。例如我在记录25上面加了`Next-Key Locks` 排他锁，那么其他事务无法修改25这条记录，也无法插入14 ~ 24的记录。 |
| Insert Intention Lock（插入意向锁） | 一种特殊的锁结构。表示此事务想在某个间隙插入记录。还是上面的例子，如果记录25上没有`Gap Locks`和`Next-Key Locks`，那其他事务可以直接插入14 ~ 24的记录，但如果有这两种锁，则其他事务需要在记录25上创建`Insert Intention Lock`等待。但注意一点：`Insert Intention Lock`只和`Gap Locks`和`Next-Key Locks`互斥，`Insert Intention Lock`之间是不不互斥的。其他多个事务可以同时在记录25上创建多个`Insert Intention Lock`。 |

## 元数据锁 MDL

MDL全称为`metadata lock`，即元数据锁。要了解元数据锁要先了解MySQL元数据。什么是元数据呢？库信息、表信息、索引信息、视图信息、字段信息、支持的字符集、权限等等都属于元数据。
 MDL锁主要作用是维护表元数据的数据一致性，用于解决或者保证DDL操作与DML操作之间的一致性。该锁是Server层的锁并不是引擎层的锁。DML操作需要MDL读锁，DDL操作需要MDL写锁（同样读读共享，读写互斥，写写互斥）。

## 全局锁

全局锁就是对整个数据库实例加锁，该数据库下所有表都被锁定。所有的数据更新（增删改、事务提交）、DDL等都会阻塞。

# 日志

## redo log

`redo log` 存储的是对页面的物理修改。类似于“*将Page10的第10~20字节从xxx改为yyy*”这种语义。正式由于 `redo log` 的这种语义，使其非常适合用作数据恢复。
 `redo log` 是以组的形式写的。`redo log` 组的单位是`mtr`（`Mini-Transaction`），一个 `mtr` 中包含多条 `redo log`。`mtr` 是逻辑上的一组原子操作。比如你向一张表插入一条数据，除了会写聚簇索引里对应的页面，所有涉及的二级索引页面也需要改动，否则内部数据就不一致了。一个事务可能包含多条SQL，一条SQL可能包含多个 `mtr` ，一个 `mtr` 可能包含多个 `redo log`。
 `redo log` 磁盘存储是有固定大小限制的，在这个大小内循环使用。一般来讲，`Buffer Pool`中的页面刷新会磁盘，对应的事务说明已经持久化到数据库页面中了，其`redo log`也就无用了，可以覆盖掉。但如果存在活跃时间非常长的大事务，使得 `redo log` 磁盘空间写完了还是无法释放掉最开始的 `redo log`，则会同步将 `Buffer Pool` 中的脏页从早往后刷盘，然后对应的 `redo log` 可以被覆盖。

> 问：`Buffer Pool` 和 `redo log` 是如何联动的？怎么知道哪些页面刷盘后哪些 `redo log` 可以被覆盖？
>  答：是有一个 `LSN`（`Log Sequence Number`）将它们串连起来的。`LSN` 可以认为是 `redo log` 的序列号。`Buffer Pool`中会维护一个FIFO队列，其中是脏页（被修改过但还未刷盘的页面）。每个页面都会记有所有修改过自己事务的最小`LSN`和最大`LSN`。因为 `redo log` 是顺序写入的，最新的 `redo log` 可以覆盖最老的`redo log`。什么时候可以覆盖呢？只要 `redo log` 的`LSN`小于`Buffer Pool` 中最早的脏页的最小 `LSN`，这些`redo log`就可以被覆盖掉。否则需要先将脏页刷盘，然后再次判断哪些 `redo log`可以被覆盖。

## binlog

`binlog` 存储的是对页面的逻辑修改。可以简单认为如“*update member set phone = '110' where user_id = 1;*”这种SQL，当然，因为一些特殊原因比如涉及函数调用、计算等，`binlog` 会有特殊处理。`binlog` 也有 `statement` ，`row` 以及 `mixed` 三种记录格式，可以都了解一下。【记录的方式是行，即如果批量修改数据，记录的不是批量修改的SQL语句事件，而是每条记录被更改的SQL语句，因此，ROW模式的binlog日志文件会变得很“重”。】
 `binlog` 是MySQL高可用高拓展的基础。比如MySQL的主从复制就是依靠传播 `binlog` 实现的；很多公司也会监听 `binlog` 做 `redis` 缓存二次删除等。
 当然，正如前面提到的，在恢复数据过程中也需要 `binlog` 的参与。

## undo log

`undo log` 维护记录的历史版本。其在MVCC中用作实现版本链，同时事务回滚等操作也都需要其参与。

作者：梓喵
链接：https://juejin.cn/post/7061575877577932837

乐观锁、悲观锁更多是从业务逻辑上考虑更新的先后顺序。



问题一：Mysql怎么保证一致性的？*
OK，这个问题分为两个层面来说。
从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。

但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给B账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。

从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！

*问题二: Mysql怎么保证原子性的？*
OK，是利用Innodb的`undo log`。
`undo log`名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。
例如

- (1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据
- (2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作
- (3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作

`undo log`记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

`ps`:具体的undo log日志长啥样，这个可以写一篇文章了。而且写出来，看的人也不多，姑且先这么简单的理解吧。

*问题三: Mysql怎么保证持久性的？*
OK，是利用Innodb的`redo log`。
正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。
*怎么解决这个问题？*
简单啊，事务提交前直接把数据写入磁盘就行啊。
*这么做有什么问题？*

- 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
- 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。

于是，决定采用`redo log`解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在`redo log`中记录这次操作。当事务提交的时候，会将`redo log`日志进行刷盘(`redo log`一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将`redo log`中的内容恢复到数据库中，再根据`undo log`和`binlog`内容决定回滚数据还是提交数据。

*采用redo log的好处？*
其实好处就是将`redo log`进行刷盘比对数据页刷盘效率高，具体表现如下

- `redo log`体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
- `redo log`是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

`ps`:不想具体去谈`redo log`具体长什么样，因为内容太多了。

*问题四: Mysql怎么保证隔离性的？*
OK,利用的是锁和MVCC机制。还是拿转账例子来说明，有一个账户表如下
表名`t_balance`

| id   | user_id | balance |
| ---- | ------- | ------- |
| 1    | A       | 200     |
| 2    | B       | 0       |

其中id是主键，user_id为账户名，balance为余额。还是以转账两次为例，如下图所示
![img](https://gitee.com/workerbo/gallery/raw/master/2020/725429-20190509210141389-2124700127.jpg)

加锁后就变成了当前读【事务2更新】

至于MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在`undo log`中。
如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。
由于MVCC机制在可重复读(Repeateable Read)和读已提交(Read Commited)的MVCC表现形式不同，就不赘述了。

但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中【MySQL默认隔离级别】，是满足隔离性的。