> ## 深入理解JVM

------

##### Java内存管理

> ###### 运行时数据区

1. 计数器：记录的是虚拟机中字节码指令的地址，解释执行。
2. 虚拟机栈：【**栈帧：局部变量表、操作栈、动态链接、方法出口**】：方法执行的内存模型。
3. 堆：对象所在地。可以有线程私有的缓冲区。
4. 方法区：存放类型等元信息、JIT、常量。运行时常量池：class的符号引用和常量。运行时通过intern加入。
5. 直接内存：配合NIO，避免在native堆和java堆来回切换
6. , jdk1.8后, 永久代被移除, 方法区【设计规范名词】移至[Metaspace](http://www.manongjc.com/detail/13-tcynadljqptppzb.html), 字符串常量移至Java Heap。元空间不再虚拟机中, 而是使用本地内存。

> ###### 对象访问

1. 对象的创建、布局、访问。
2. new 先检查常量池是否有类符号引用，没用就加载类。加载完毕就确定了对象大小。然后通过指针碰撞【内存规整】或者自由列表分配空闲内存。【并发的时候通过CAS或者TLAB来保证内存的正确分配】字段初始化为零，再设置值【先头设置，然后调用构造函数】。最后复制给栈中变量。
3. 对象头中有markword【根据状态动态存储内容】类型指针【不必须。看实现方式】。数组的长度设置在对象头中【所以对象的内存大小固定，扩容需要复制】。对象体中存具体数据，包含父类中的字段。
4. 对象访问【**对象内存布局**】：1.通过句柄池【**同时得到执行实例数据instanceOopDesc和类型数据的指针instanceKclass**】，这样在对象地址变动时，只需要。2直接引用：直接访问到实例数据地址，然后在实例数据中有执行类型数据的地方。
5. Compressed Class Space 是 Metaspace 的一部分，默认大小为 1G。所以其实 Compressed Class Space 这个名字取得很误导，压缩的并不是 Klass，而是 Klass*【指针】。[32位最大寻址空间2^32=4G * 8=32 Gb容量]

> OOM异常

验证各个区域存储的内容，快速分析出错区域。

1.堆内存溢出。【分析是否是内存泄漏导致的内存溢出】

2.栈stackoverError、内存溢出。【多线程时减少最大堆大小、线程容量大小。-Xss】

3.常量池溢出。【-XX：permSize=】

4.方法区溢出【框架通过cglib在运行时生成了大量的类】

5.本机直接内存溢出。【只有unSafe才能获取，并且只有rt.jar中的包才能获取】

------



#### 内存各个区域的分配和回收【目标、时间、方式】

栈帧的内存大小在编译期就可知。因为栈的回收是已知的。

堆和方法区是动态分配和回收的【接口的实现类，不同分支在运行时创建的对象不同】

1. 引用计数法【循环引用不能被清除】
2. 根搜索算法【GC点是否可达。1、栈中。2、静态变量 3、常量 】
3. 对象需要经过两次标记才会被回收。【finalize方法会被调用（重写，且没被虚拟机调用过），但是不确保会完全执行。可以实现自救一次】
4. 方法区垃圾回收：废弃常量和类【条件苛刻】

> ###### 垃圾回收算法

1.标记清除算法【效率低，空间碎】-->2.复制算法【空间只能使用一半，适用于新生代（大多数的对象生存时间短）。Eden和一块survivor空间共90%空间用于存放空间，在垃圾回收时复制剩余对象到另一块survivor空间，空间不够通过担保机制进入到老年代，】-->3.标记整理算法【标记后移动再清理。适用于老年代】

> 垃圾回收期

#### ![image-20201110105734805](https://gitee.com/workerbo/gallery/raw/master/2020/image-20201110105734805.png)

1.Serial收集器【必须停止其他工作线程。Serial old 工作在老年代】-->2.parNew收集器【工作在新生代，多线程（parallel，并行工作，但是工作线程依然处于等待状态）。适用于多核，此时处理效率高于Serial。和CMS配合处理】

3.parallel Scavenge收集器【多线程，更关注吞吐量，没有太多交互。】

4.serial Old：【单线程，和Serial、Ps配合。】

5.parallel  old 【多线程，配合parallel Scavenge】

6.CMS【追求最短停留时间。唯一采取标记清除算法的。四步。初始标记和重新标记需要停顿，并发标记和并发清除可以和工作线程一起。【并发清除中当预留空间不足触发mode failure失败有Serial接替处理】】

7.G1【将堆分为多个区域、通过一个表维护垃圾多的区域。非常精确的控制停顿】

> 内存分配 

内存对象分配与收集器策略以及虚拟机参数设置有关

1.对象优先在Eden区域。2.大对象直接分配在老年代【需要连续的空间，避免复制】3.长期存活的对象进入老年代。【一次minor GC年龄增加一次。阈值通过虚拟机参数设置。或者相同年龄的对象空间占用达到survivor的一半】

空间分配担保：Minor GC之前 老年代如果剩余空间小于之前晋升的平均大小。则直接Full GC。小于时如果允许担保则只进行minor GC。

![image-20201110140635804](https://gitee.com/workerbo/gallery/raw/master/2020/image-20201110140635804.png)

6. 



##### JVM调优



##### JVM执行子系统

JVM和字节码存储格式构成了语言无关性【同时平台无关性】的基石。

Java语言的语义最终都会由多条字节码指令组合来表达，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。因此，有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于Java的语言特性提供了发挥空间。

高位在前：高位在低字节。

字节码有严格的顺序、长度、内容。【由表和无符号数组成】

编译器和虚拟机会动态生成类。

接口不能实例化，所以只能有静态常量。

类、接口、方法、字段在解析阶段都需要将常量池庄的符号引用变为直接引用。

所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。

在静态分派的时候，重载根据静态类型决定实际调用方法。【编译期间决定】

动态类型语言和静态类型语言【编译、连接期或者运行期进行类型检查】

