UML[图解](https://www.cnblogs.com/youxin/archive/2013/05/11/3072858.html)

23[种设计模式快速](https://www.cnblogs.com/steffen/p/11400509.html)

OOP1：接口抽离行为。【变化、不变抽离、利于代码复用】

OOP2：多用组合，少用继承

OOP3:   开闭原则

> ###### 1.策略模式&状态模式

- 状态模式【通过状态控制行为、状态之间根据条件会转化导致上下文持有的状态变化】

    局部化状态的行为   

     动作 【对外开发的方法】      状态【持有的所有状态，以及当前的状态】     行为【动作根据状态的不同触发对应的行为】

  在上下文对象中，所有状态对象定义在其中，同时持有自己的状态。所有状态对象在构造器中初始化并持有上下文。

- 策略模式【替换算法】

    运行时动态改变行为。【即根据条件注入不同的策略】

> ###### 2.组合模式&迭代器模式

- 迭代器模式

    封装数据结构+迭代器实现【封装了底层实现】

- 组合模式

    ![image-20201119145332890](https://gitee.com/workerbo/gallery/raw/master/2020/image-20201119145332890.png)

> ###### 3.代理模式和&装饰模式&适配器模式

- 代理模式【控制对象的访问】

- 装饰模式

     避免继承的滥用、可以多次装饰。和被装饰类实现同一个接口并注入被装饰类

- 适配器模式

     兼容不同的接口。

> ###### 4.观察者模式和中介模式

- 观察者模式

  注册到被观察者（订阅主题），主题【数据持有】被触发进行消息发布。

> ###### 5.工厂模式&抽象工厂模式



> ###### 6.单例模式

- 饿汉模式【线程安全、适合不耗资源的对象】
- 懒汉模式【需要双重检查锁定和volatile，多线程只会在对象还未创建时第一个if处发生锁争用】

> ###### 7.命令模式【封装调用】

各种接受者【动作】---【注入】---命令对象【实现了命令接口】--【注入】-调用者【执行命令对象的方法】

![image-20201119142250142](https://gitee.com/workerbo/gallery/raw/master/2020/image-20201119142250142.png)

Command实现了解耦，包裹各种各样的动作接口统一让调用者调用。

> ###### 8.模板模式

> ###### 9.门面模式

> ###### 10.解释器模式和建造者模式

建造者模式：通过一个构造器类【拥有所有的属性，方法同名且返回构造器对象。产品通过builder生成构造器对象（同时生成一个产品对象）。构造器有一个build方法返回构造成功的产品对象。】

构造器可以有多个，指挥者和产品可以分离。

> ###### 11.访问者模式

静态分派（Static Dispatch）就是按照变量的静态类型进行分派，从而确定方法的执行版本，即所谓的编译时多态，发生在编译时期。方法重载就是静态分派最典型的应用。动态分派判断的方法是在运行时获取 Dog 和 Cat 的实际引用类型，再确定方法的版本，而由于此时判断的依据只是实际引用类型，只有一个判断依据，所以这就是单分派的概念，这考量标准只有一个，即变量的实际引用类型。

访问者模式通过两次动态分派，第一次对 accept() 方法进行动态分派，第二次对访问者的 visit() 方法进行动态分派，从而达到根据两个实际类型确定一个方法的行为效果。【伪动态双分派】

> ###### 12.责任链模式

一个请求对象经过链条上对象的处理。一种是集合循环，一种是链条上对象持有下一个对象