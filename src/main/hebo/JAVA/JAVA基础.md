jar只是用于存放class的容器，它并不关心class之间的依赖。

从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果`a.jar`必须依赖另一个`b.jar`才能运行，那我们应该给`a.jar`加点说明啥的，让程序在编译和运行的时候能自动定位到`b.jar`，这种自带“依赖关系”的class容器就是模块。





基本类型转换不同，数据发生了变化。但是基本数据类型不是对象，如果涉及到自动装箱和拆箱，实际上是调用类似Integer.parseInt()和Integer.valueOf()实现。

   父类向子类强制转换，如果成功不会有任何数据丢失，如果不是子类，那么会报错。基本类型之间的转换，如果是大范围向小范围的转换，有可能发生数据丢失或者精确丢失。



**.对于实现AutoCloseable接口的类的实例，将其放到try后面（我们称之为：带资源的try语句），在try结束的时候，会自动将这些资源关闭（调用close方法）。**

#### SPI[机制](https://zhuanlan.zhihu.com/p/212850943)

DriverManager 在静态代码块中通过ServiceLoader.load方法创建一个ServiceLoader对象【创建过程中查询到了所有服务接口的实现类名数字】，ServiceLoader中的一个迭代器在迭代的过程中加载和实例化类，服务实现类的静态代码实现注册到DriverManager registeredDrivers当中。【重点是使用了线程上下文类加载器】



Java 对象不使用时，要赋值为 null？

slot：局部变量的存储单元位置

**`System.gc();`触发GC时，`main()`方法的运行时栈中，还存在有对`args`和`placeHolder`的引用，GC判断这两个对象都是存活的，不进行回收。** 也就是说，代码在离开if后，虽然已经离开了`placeHolder`的作用域，但在此之后，没有任何对运行时栈的读写，`placeHolder`所在的索引还没有被其他变量重用【重用slot会被覆盖】，所以GC判断其为存活。



那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的

T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。【是在泛型定义的基础上的】

类型参数 T 只具有 一种 类型限定方式：T extends A。泛型定义只确定下届没有意义，无法读取。



###### 浮点数存储

不管float还是double 在计算机上的存储都遵循IEEE规范，使用二进制科学计数法，都包含三个部分：符号位，指数位和尾数部分。其中float的符号位，指数位，尾数部分分别为1,  8,  23.     双精度分别为1,  11,  52。

精度主要取决于尾数部分的位数，float为23位，除去全部为0的情况以外，最小为2的-23次方，约等于1.19乘以10的-7次方，所以float小数部分只能精确到后面6位，加上[小数点](https://www.zhihu.com/search?q=小数点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A81573345})前的一位，即有效数字为7位。  类似，double 尾数部分52位，最小为2的-52次方，约为2.22乘以10的-16次方，所以精确到小数点后15位，有效位数为16位。







 