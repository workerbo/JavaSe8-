WEB服务器每次在调用web资源的service方法之前，
都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：
    调用目标资源之前，让一段代码执行。
    是否调用目标资源（即是否让用户访问web资源）。
    调用目标资源之后，让一段代码执行。

Filter的创建和销毁由web服务器负责
用户在配置filter时，可以使用<init-param>为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了
filter初始化参数的filterConfig对象传递进来。
Filter的部署分为两个步骤：
　　1、注册Filter
　　2、映射Filter

先入后出
多个的时候是这样工作的。【基于函数回调】
--> 表示请求，<-- 表示响应。

-->  A
       --> B
             --> Servlet
             <--
      <-- B
<-- A

https://blog.csdn.net/reggergdsg/article/details/52821502
https://blog.csdn.net/reggergdsg/article/details/52962774

拦截器基于反射【动态代理】

    java.uitl.date 是java.sql.date java.sql.time java.sql.timestamp的父类


    Mybaits plus 的想法是类似jpa  注解加上BaseMapper


    概括要点就是：

第一点：Easyexcel重写了poi对07版Excel的解析，内存使用率大大降低。

第二点：Easyexcel封装了poi对03版Excel的解析，在使用上，变得更加简洁。


====java编程思想   4.15
https://blog.csdn.net/thinkGhoster/article/details/2313438
匿名内部类之所以可以访问外部成员变量，是因为在底层将这个局部变量的值传入到了匿名内部类中，并且以匿名内部类的成员变量的形式存在，这个值的传递过程是通过匿名内部类的构造器完成的。
用final修饰实际上就是为了保护数据的一致性。
在JDK8中如果我们在匿名内部类中需要访问局部变量，那么这个局部变量不需要用final修饰符修饰。看似是一种编译机制的改变，实际上就是一个语法糖（底层还是帮你加了final）。
定义成final类型的基本类型的变量的隐式初始化并不起作用。

接口可以包含成员变量，都隐含是static并且final

判断方法的重载是根据“方法名”、“方法参数”和“方法参数的顺序”， 如果在重载方法时，其他的都相同，仅仅是返回类型不同，则会出现二义性
方法覆盖要求返回类型必须一致，而方法重载对此不做限制。
方法覆盖 返回参数、异常、权限只能是相同或者子类

当构建一个类的实例时，编译器依次主要做以下三件事情：
      1、为对象分配内存空间；
      2、初始化对象中实例变量的值，初始化值可以是缺省值或按指定的方式初始化。“指定的方式”可能是直接赋值、表达式赋值或调用其他任何方法赋值；
      3、调用对象的构造方法。
  初始化过程：先初始化父类的静态代码--->初始化子类的静态代码-->(创建实例时,如果不创建实例,则后面的不执行)初始化父类的非静态代码--->初始化父类构造函数--->初始化子类非静态代码--->初始化子类构造函数。
  类只有在使用New调用创建的时候才会被JAVA类装载器装入；
 静态变量只有在必要的时候才执行初始化：创建对象时、用类名直接访问时、在装载类时
 非静态块的初始化的作用：保证了无论调用哪个构造方法都执行特定的初始化操作。

=========慕课网java架构师课程
1.单向-双向-服务器拆分-数据缓存-集群-读写分离-微服务化【容器化】-性能优化与Netty

注意： ①. 聚合工程里可以分为顶级项目（顶级工程、父工程）与子工程，这两者的关系其实就是父子继承的关系
子工程在maven里称之为模块（module），模块之间是平级，是可以相互依赖的。
②. 子模块可以使用顶级工程里所有的资源（依赖），子模块之间如果要使用资源，必须构建依赖（构建关系）

购物车用后端数据刷新【不直接用cookie，因为价格可能会变动】
前后端都应该校验，推荐在BO上用Harbernet校验注解
存数据快照，因为关联的数据后期可能更改 逻辑删除
synchronize关键字在集群无用，也不能在数据库统一加锁【性能问题】  推荐分布式锁，乐观锁
全局ID
小数当成整数存
redis value序列化方式
redis 相比memcahe 持久化 单线程
nginx 的work进程处理客户端阻塞了可以继续处理下一个【异步非阻塞】  多路复用器  抢占机制



=======代码整洁之道  4.16
https://blog.csdn.net/u011240877/article/details/87967637?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1

1.每个函数后面都跟着位于下一个抽象层级的函数。
3.最理想的函数是零参数函数，其次是单参数函数
4.要确保函数只做一件事，函数中的语句都要在同一抽象层级上。函数中混杂不同抽象层级，往往让人迷惑。
5.分隔指令与询问
8.用代码来阐述。例如：一段长判断用方法抽离 更加清晰
9.每组代码行展示一条完整的思路，这些思路用空白行区隔开。


10.switch 出现多次，就要考虑使用多态来减少 switch 语句出现的次数
11.注释： 警示、提醒、复杂实现的简要概括 TODO
12.返回空对象好于返回 null，尽可能的避免空指针的出现。


6.使用异常替代返回错误码，对错误的逻辑直接抛出异常，就不用去挨个判断返回了.
7.try/catch代码块丑陋不堪，它们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把try和catch中的代码块的主体部分抽离出来。
12.定义异常时，要考虑它会被如何捕获。CheckedException 如果不处理，就得强制抛出去，那样会影响所有调用链。
13.处理逻辑前，优先处理边界和异常
14.使用的框架代码里使用关键字 throw new 进行搜索，看看什么情况下会抛出什么异常

====深入理解java虚拟机  4.16
https://blog.csdn.net/sanhewuyang/article/details/95380620


=====Java并发编程详解  4.17
https://blog.csdn.net/sanhewuyang/article/details/95937793
线程具有生命周期
1.新建：仅有JVM为其分配内存并初始化
2.就绪：线程实例调用start()方法之后，JVM会为该线程创建方法调用栈和程序计数器
3.运行状态：就绪状态的线程获得CPU后，开始执行run(）方法的线程执行体
4.死亡状态：执行完毕或者未捕获的Exception或Error
5.阻塞状态:休眠状态  等待状态

6.线程的start方法剖析：模板设计模式在Thread中的应用
Thread的run()和start()方法就是一个典型的模板设计模式，父类编写算法结构，子类实现逻辑细节，
Runnable接口的引用以及策略模式在Thread中的应用。
 Runnable 的 run() 方法，还是 Thread 类本身的 run() 方法（事实上 Thread 类也是实现了 Runnable 接口）都是想将线程的控制本身和业务逻辑的运行分离开

 Thread的run方法是不能共享的 ，即线程A不能把线程B当做自己得执行单元，而使用Runnable接口很容易就能实现这一点。使用同一个Runnnable实例可以构造不同的Thread实例。
 // 将数据抽象成一个类,并将数据的操作为这个类的同步方法.
        // 使用同一数据构造不同的runnable 接口.

可以粗略的认为Java进程的内存大小为：堆内存+线程数量*栈内存。
Thread负责线程本身相关的职责和控制，而Runnable则负责逻辑执行单元的部分。	
JVM中进程中没有一个非守护线程，那么JVM会退出，即守护线程具备自动结束生命周期的特性，一般用于执行后台任务，也被称为后台线程。

sleep方法会使当前线程进入指定的毫秒数的休眠，暂停执行，并且不会放弃monitor锁的所有权。
调用一些方法(也称可中断方法)会使的当前线程进入阻塞状态，而调用当前线程的interrupt方法就可以打断阻塞。并不是等于该线程结束，仅仅是打断了当前线程的阻塞状态。线程阻塞被打断会抛出InterruptException异常。

同一个monitor的lock
多个锁的交叉导致死锁：一个方法有多个Monitor
java的Monitor机制：每一个对象都分配了监听器
https://blog.csdn.net/boyeleven/article/details/81390738


对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。



=======java8实战



=======mysql高性能实战




======啊哈算法


======英语语法


=======阿里巴巴 Java 开发手册
1.模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式
2.枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。 
3.获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。 
4.initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即loader factor）默认为 0.75
5.捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类
6.泛型PECS原则  泛型通配符可以接受多种集合实例【每种只能有一种类型】  确定下届的存 确定上界的读【指实例从外传入函数后的操作】  泛型在编译时擦除
https://blog.csdn.net/xx326664162/article/details/52175283
7.对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。
说明：logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);
如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，
如果 symbol 是对象， 会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。
正例：（条件）建设采用如下方式 if (logger.isDebugEnabled()) {    logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);   }      
正例：（占位符） logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol); 

8.异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。 正例：logger.error(各类参数或者对象 toString() + "_" + e.getMessage(), e); 
9.好的单元测试必须遵守 AIR 原则。 
10 编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量

11.跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作
简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。
1）检查Referer字段 2）添加校验token 【正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数】


14.count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 
15.使用 ISNULL()来判断是否为 NULL 值。NULL 与任何值的直接比较都为 NULL    IF函数代替简单的case when
16.不得使用外键与级联，一切外键概念必须在应用层解决 【级联更新是强阻 塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。】
17.当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。
18.in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控 制在 1000 个之内

19.分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进 行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印 日志，在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能 带上参数信息，相当于保护案发现场。Web 层绝不应该继续往上抛异常，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面。开放接口层要将异常处理成错误码 和错误信息方式返回。

20.<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的 <dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。 


======JVM虚拟机调优
当一个实例方法被调用的时候,第0个局部变量一定是用来存储被调用的实例方法所在的对象的引用(即 Java 语言中的“this” 关键字)
操作数栈中的数据必须被正确地操作,这里正确操作是指对操作数栈的操作必须与操作数栈 栈顶的数据类型相匹配,
动态链接的作用就是 将这些符号引用所表示的方法转换为实际方法的直接引用。

https://blog.csdn.net/dc_726/article/details/7944154

Class文件格式采用一种类似于C语言
结构体的伪结构来存储，这种伪结构中只有两种数据类型：无符号数和表。
无符号数就是u1、u2、u4、u8来分别代表1个、2个、4个、8个字节。表是由
多个无符号数或其他表构成的复合数据类型，以“_info”结尾。
因为Java程序方法中的代码经过javac编译之后形成字节码存在了Code属性内




Java SPI 实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。




====单例

常见的单例写法有他的弊端，存在安全性问题，如：反射【可以通过在构造函数定义异常】，序列化的影响【序列化会通过反射调用无参数的构造方法创建一个新的对象。主要在Singleton中定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。】。
提倡使用单元素枚举类型的方式来实现单例，首先创建一个枚举很简单，其次枚举常量是线程安全的，最后有天然的可序列化机制和防反射的机制。


枚举类型是阻止反射来创建实例


====泛型

Java泛型带到的好处1.代码复用，2.避免类型转化（相对于使用Object类型实现泛型而言） 其中通配符丢失了类型信息，通常在方法参数中才会使用通配符,使得这个方法可以引用多种泛型集合。这个和范型方法不一样，这里只是一个引用变量
对于new ArrayList<String> 和 new ArrayList<Integer> 来说，两个对象在编译之后两者是一样的，通过反射均可以向集合中添加任意类型的对象；
https://www.jianshu.com/p/d468eae37a10

====反射
Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法。并且对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。
本来String对象是不可变对象，但通过反射可以改变String类的值。（提供了方法修改字符数组并且final失效）
在java中，有两种RTTI的方式，一种是传统的，即假设在编译时已经知道了所有的类型；还有一种，是利用反射机制，在运行时再尝试确定类型信
允许在运行时去探知、加载、调用在编译期完全未知的class，可以在运行时加载该class，生成实例对象（instance object），调用method，或对field赋值。

transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化


System自带的复制数组的方法System.arraycopy(src, 0, dest, 0, src.length);







nio

===集合



事实上线程安全本身就不允许读的时候被修改。


https://www.cnblogs.com/fsmly/p/10721433.html
Java中的锁——Lock和synchronized中介绍的ReentrantLock和synchronized基本上都是排它锁，意味着这些锁在同一时刻只允许一个线程进行访问，
而读写锁在同一时刻可以允许多个读线程访问，在写线程访问的时候其他的读线程和写线程都会被阻塞。读写锁维护一对锁(读锁和写锁)，通过锁的分离，使得并发性提高。


=======字符串


不可变对象有很多优势：
不可变对象可以提高对象的效率和安全性。如果你知道一个对象是不可变的，那么需要拷贝这个对象的内容时，就不用复制它的本身而只是复制它的地址，复制地址(通常一个指针的大小)需要很小的内存效率也很高。对于同时引用这个对象的其他变量也不会造成影响。

不可变对象对于多线程是安全的，因为在多线程同时进行的情况下，一个可变对象的值很可能被其他进程改变，这样会造成不可预期的结果，而使用不可变对象就可以避免这种情况。
