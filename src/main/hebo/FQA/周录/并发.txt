Java Web中的Servlet程序在Servlet容器的支持下采用单实例多线程的工作模式，Servlet容器为你处理了并发问题。
不变对象是线程安全的
volatile的关键字，它是一种简单的同步的处理机制、


多线程编程的目的,就是"最大限度地利用CPU资源"
多线程一定比单线程慢,多线程提高的是并发数量  【一定数据规模以上，多线程执行总时间变长，响应时间变快（存在上下文切换的消耗，但是在一定时间提升了CPU利用率和占用率）】

 CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。
CAS compare and change  在java中不加锁实现多线程更改共享数据   比较后不相等的话重新读取进行操作  底层是汇编指令  lock【防止其他线程在比较后赋值间隙对数据赋值】  cmpxchg  指令

ABA问题  多个线程更改后的值和原值相同【可以加标识或者版本号识别】
JVM的实现 hotSpots openJDK J9  



synchronized同步上锁 是给锁对象添加锁信息
锁的四个级别 以及状态变化【竞争激烈程度】
 无锁【new】  偏向锁【java11默认打开上锁，存放当前线程的指针】    和jdk版本有关
 轻量级锁【自旋锁也称无锁（等待的时候） 存在竞争，用CAS的方式将markwork设置为指向线程栈中lock  Record】   在用户态
  重量级锁[自旋超过一定的次数（CPU资源消耗 ），一般由jvm决定  向OS申请资源，加入当前锁等待队列，由OS调度，不消耗CPU资源了]  信号互斥量  在内核态

  锁降级存在 GC的时候
  锁消除  局部变量的锁自动消除【栈私有】  类似StringBuffer 
  锁粗化  成员变量循环中将锁升级到循环上 【减少加减锁次数】

  JIT JSUT IN TIME  把高频的代码直接编成机器语言

######   volatile

  1.保证线程的可见性


CPU速度是磁盘的百万倍  寄存器最快 CPU有三层缓存
线程是CPU执行的基本单位 进程是CPU分配资源的单位
超线程  一个ACL  对应多个PC|registers   直接切换 不用去保存上下文
cache line(64字节) 局部性原理 一次读取一行  CPU级别缓存行数据一致性单元【valatile底层原理】  加了volatile后数据有变动，必须通知其他线程重新读取数据  【缓存行对齐】所以有时候会填充块到64字节，这样不用通知其他线程  空间换时间

  2.禁止指令重排
   JVM内存屏障


  同步问题解决的是共享数据【不共享数据不用同步】、



  ====
  https://blog.csdn.net/one_Jachen/article/details/78157209
  JVM内存模型
  Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存，线程只能访问自己的工作内存，不可以访问其它线程的工作内存。

  JAVA多线程—共享变量的可见性问题

  2.调用其他synchronized加锁的代码块，系统会从主内存拉取变量
  3.只要不影响到变量的值，变量不参与运算，则不会从主内存中拉取，比如while，if，赋值给其他变量
  4.调用了被synchronized加锁的方法，或者方法中有被synchronized加锁的代码块，那么变量将会从主内存中拉取。  例：System.out.println(); 里面有同步锁
  5.线程休眠会使从主内存中拉取变量。


  共享变量不可见主要有下列原因：

a.线程的交叉执行

b.重排序

c.共享变量未能及时更新



综上所述：用 volatile 关键字修饰的共享变量，编译成字节码后增加 Lock 前缀指令，该指令要做两件事：

1. 将当前工作内存缓存行的数据立即写回到主内存。
2. 写回主内存的操作会使其他工作内存里缓存了该共享变量地址的数据无效（**缓存一致性协议保证的操作**）。

Lock前缀指令还有内存屏障作用：

1. 确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的（**即在执行到共享变量时，因为内存屏障的存在，会把它前面的操作都写回主内存，然后再执行共享变量的操作，对共享变量的操作一执行完也会写回主内存**）。
2. volatile 关键字由于不会引起线程上下文切换和调度，在只需要保证 **可见性** 或者 **有序性** 时，可以使用 volatile 关键字，提升性能。【所以一般在使用 volatile 关键字的地方，常常出现 CAS。JUC框架依靠这两点实现轻量级的锁】

使用条件：1.与当前状态无关 2.不在不变式中  
使用场景：1.状态标识 2，双重检查锁定 3.独立观察  4.volatile bean 5.读volatile 写scychrized
JMM 执行引擎  运行数据区【堆 方法区（常量池） 本地栈、虚拟栈、PC（线程私有）】  本地代码库




https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9006463299089281839%22%7D&n_type=1&p_from=3
  threadLocal：作用是让变量不再共享，而是各个线程私有【例：在同一事物中如何保证拿到的是同一个数据库连接 私有单例】
   实现：统一管理多线程的各个私有变量【一个threadlocal只能容纳不同线程的一个Entry】。各个线程有自己的threadlocalmap。统一让threadlocal做Key.
   Key被弱引用包裹，并且需要手动remove才不会内存泄漏
  线程本地存储本质就是避免共享，在使用中注意内存泄露问题和hash碰撞问题即可。使用还是很广泛的像spring中事务就用到threadlocal。
  弱引用  当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象【前提是没有其他强引用】。在java中，用java.lang.ref.WeakReference类来表示。
  虚引用  管理堆外内存 例：NIO

=====================
JMM


  垃圾回收的基本原理（算法思路都是一致的：把所有对象组成一个集合，或可以理解为树状、图结构，从树根开始找，只要可以找到的都是活动对象，如果找不到，这个对象就被回收了）
  主要处理步骤：将线程挂起→确定roots→创建reachable objects graph→对象回收→heap压缩→指针修复。
  标记 --> 压缩【使内存空间变得连续】
  https://www.jianshu.com/p/5261a62e4d29

  分代收集，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法（4.1-4.3）进行垃圾回收（GC），以便提高回收效率。
  整理算法：标记-整理  copy
  在年轻代【copy】中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代【标记】中
  对永久代的回收主要回收两部分内容：废弃常量和无用的类。


  happens-before 应该翻译成：前一个操作的结果可以被后续的操作获取。

  并发问题源头：三大特性:可见性、原子性、有序性。
  可见性缓存再加上多颗CPU并发【可见性问题】
  原子性指的就是一个或多个操作在CPU中执行不会被中断的特性称为原子性。【可能导致修改被覆盖】
  指令重排
  https://www.jianshu.com/p/e662bb611360

  锁的本质实现就是:当一个线程获取到锁就是把它的线程id写入锁对象的对象头,来判断唯一。

  对一个资源的保护必须是同一个锁！但是呢如果是没有关联性的资源我们要细分粒度

  synchronized修饰的是静态方法，那表明锁的是当前的Class对象，如果修饰的不是静态方法，那表面锁的是当前的实例对象this。

  通知-等待机制 提升效率

  并发编程领域，有两大核心问题:互斥、同步

Synchronized进入阻塞之后就没办法唤醒它，
  所以Lock【破环不可抢占的条件：避免死锁】提供了这三种方式来弥补Synchronized的不足使得我们能写出更加安全，健壮的代码。


原子类的实现原理是volatile+cas

Semaphore 用来多线程互斥问题，相对于synchronized和Lock来说它允许多个线程访问一个临界区


由于finalize()【释放非Java 资源】方法的调用时机具有不确定性，从一个对象变得不可到达开始，到finalize()方法被执行，所花费的时间这段时间是任意长的。我们并不能依赖finalize()方法能及时的回收占用的资源，可能出现的情况是在我们耗尽资源之前，gc却仍未触发，因而通常的做法是提供显示的close()方法供客户端手动调用




内部类使得多重继承的解决方案变得完整，内部类对象是外部类的成员变量。在任何非静态内部类中，都不能有静态数据
1.内部类与外部类可以方便的访问彼此的私有域
2.内部类是另外一种封装，对外部的其他类隐藏。

成员内部类是依附外部类的，只有创建了外部类才能创建内部类。

模拟多线程：thread.sleep(5000) 然后多次运行 



创建对象的并发考虑上，一种是分配内存空间动作的同时进行同步处理，CAS配上失败重试的方法保证更新操作的原子性。



===========
synchronized不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以相应中断。

异步
异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中


Callable 接口 call()  计算结果，如果无法计算结果，则抛出一个异常。
Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。

Future整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。不支持链式调用、不支持多个Future合并
CompletableFuture的出现，才使得使用Java进行异步编程提供了可能。
lambda提供了函数化编程

读写锁
https://www.cnblogs.com/fsmly/p/10721433.html